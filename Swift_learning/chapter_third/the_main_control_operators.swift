//
//  the_main_control_operators.swift
//  Swift_learning
//
//  Created by Даниил Асташов on 11.10.2024.
//

import Foundation

//утверждения
/*Swift позволяет прервать выполнение программы в случае, когда некоторое условие не выполняется: к примеру, если значение переменной отличается от требуемого. Для этого предназначен специальный механизм утверждений (assertions).
 Утверждения в Swift реализованы в виде глобальной функции assert(_:_:).*/
// утверждение с двумя аргументами
//assert( someVar > 100, "Данные неверны" )
// утверждение с одним аргументом
//assert( anotherVar <= 10 )

let strName = "Дракон"
let strYoung = "молод"
let strOld = "стар"
let strEmpty = " "
var dragonAge = 230
//assert( dragonAge <= 235, strName+strEmpty+strOld )
//assert( dragonAge >= 225, strName+strEmpty+strYoung )
//print("Программа успешно завершила свою работу")


var dragonAge_new = 220
//assert( dragonAge_new <= 235, strName+strEmpty+strOld )
//assert( dragonAge_new >= 225, strName+strEmpty+strYoung )
//print("Программа успешно завершила свою работу")
//Консоль
//Assertion failed: Дракон молод


//опрератор if

/*Оператор условия if имеет четыре формы записи, различающиеся по синтаксису
 и функциональным возможностям:
  сокращенная;
  стандартная;
  расширенная;
  тернарная*/

//сокращенный синтаксис
/*if userName == "Alex" {
 print("Привет, администратор")
}*/

// переменная типа Bool
var logicVar = true
// проверка значения переменной
//10.2. Оператор условия if   191
/*if logicVar == true {
 print("Переменная logicVar истинна")
}*/

/*if logicVar {
 print("Переменная logicVar истинна")
}*/

/*logicVar = false
if logicVar {
 print("Переменная logicVar истинна")
}
// вывод на консоли пуст
Swift — это язык со строгой типизацией. Любое проверяемое выражение обязательно должно возвращать либо true, либо false, и никак иначе. По этой причине если оно возвращает значение другого типа, то Xcode сообщит об ошибке
(листинг 10.6).
Листинг 10.6
var intVar = 1
if intVar { // ОШИБКА
}
*/

//стандартный синтаксис опреатора if

/*if userName == "Alex" {
 print("Привет, администратор")
} else {
 print("Привет, пользователь")
}*/

/*// переменная типа Bool
 var logicVar = false
 // проверка значения переменной
 if logicVar {
  print("Переменная logicVar истинна")
 } else {
  print("Переменная logicVar ложна")
 }*/

//расширенный синтаксис оператора if
/*/
if userName == "Alex" {
 print("Привет, администратор")
} else if userName == "Bazil" {
 print("Привет, модератор")
} else if userName == "Helga"{
 print("Привет, редактор")
} else {
 print("Привет, пользователь")
}
*/




/*
if (..<5).contains(tenantCount) {
 rentPrice = 1000
} else if (5...7).contains(tenantCount) {
 rentPrice = 800
} else if (8...).contains(tenantCount) {
 rentPrice = 500
}
*/


//тернарный опрератор условия

/*Swift позволяет значительно упростить стандартную форму записи оператора if всего до нескольких символов. Данная форма называется тернарным
 оператором условия. Его отличительной особенностью является то, что он не
 просто выполняет соответствующее выражение, но и возвращает результат его
 работы.*/


/*проверяемое_выражение ? выражение_1 : выражение_2
 проверяемое_выражение -> Bool — вычисляемое выражение, на основании значения
 которого принимается решение об исполнении кода, находящегося в блоке.
 выражение_1 -> Any — выражение, значение которого будет возвращено, если проверяемое
 выражение вернет true.
 выражение_2 -> Any — выражение, значение которого будет возвращено, если проверяемое
 выражение вернет false.
 При истинности проверяемого выражения выполняется первый блок кода. В ином случае
 выполняется второй блок. При этом тернарный оператор не просто выполняет код в блоке,
 но возвращает значение из него.*/

var x = 44
let y = ( x > 100 ? 100 : 50 )


let a = 1
let b = 2
// сравнение значений констант
//a <= b ? print("A меньше или равно B") : print("A больше B")


/*// переменная типа Int
 var height = 180
 // переменная типа Bool
 var isHeader = true
 // вычисление значения константы
 let rowHeight = height + (isHeader ? 20 : 10 )
 // вывод значения переменной
 rowHeight // 200*/

/**ПРИМЕЧАНИЕ Отдельные выражения внутри проверяемого выражения могут быть отделены
 не только логическими операторами || и &&, но и с помощью запятой (,). Она с логической
 точки зрения работает как &&, то есть если одно из условий false, то общий результат проверки также будет false.
 let a = Int.random(in: 1...100)
 let b = Int.random(in: 1...100)
 // вариант 1 (с И)
 if a > 50 && b > 50 {
  print("a and b > 50")
 }
 // вариант 2 (c запятой)
 if a > 50, b > 50 {
  print("a and b > 50")
 }
 При этом использование запятой имеет несколько особенностей:
 • Вычисление значения выражений происходит по порядку, и если одно из выражений не
 истинно (false), то последующие подвыражения вычисляться не будут.
 • Результаты вычисления каждого подвыражения могут быть использованы в последующих
 подвыражениях.
 В следующем примере используются опционалы, изучению которых будет посвящена следующая
 глава. В нем результаты вычислений первого и второго подвыражений используются в третьем/
if let a = Int("43"), let b = Int("45"), a < b {
 print("a < b")
}*/


//оператор ветвления SWITCH

/*Нередки случаи, когда приходится работать с большим количеством вариантов
 значений вычисляемого выражения, и для каждого из возможных значений необходимо выполнить определенный код. Для этого можно использовать расширенный синтаксис оператора if, многократно повторяя блоки else if.
 Предположим, что в зависимости от полученной пользователем оценки стоит
 задача вывести определенный текст. Реализуем логику с использованием оператора if (листинг 10.19)*/

// оценка
let userMark = 4
/*if userMark == 1 {
 print("Единица на экзамене! Это ужасно!")
} else if userMark == 2 {
 print("С двойкой ты останешься на второй год!")
} else if userMark == 3 {
 print("Ты плохо учил материал в этом году!")
} else if userMark == 4 {
 print("Неплохо, но могло быть и лучше")
} else if userMark == 5 {
 print("Бесплатное место в университете тебе обеспечено!")
} else {
 print("Переданы некорректные данные об оценке")
}*/

/*switch userMark {
 case 1,2:
 print("Экзамен не сдан")
 case 3:
 print("Необходимо выполнить дополнительное задание")
 case 4,5:
 print("Экзамен сдан")
 default:
 print("Указана некорректная оценка")
}
*/

/*let userMark = 4
 // переменная для хранения сообщения
 let message: String
 202   Глава 10. Операторы управления
 switch userMark {
 case 1:
  message = "Единица на экзамене! Это ужасно!"
 case 2:
  message = "С двойкой ты останешься на второй год!"
 case 3:
  message = "Ты плохо учил материал в этом году!"
 case 4:
  message = "Неплохо, но могло быть и лучше"
 case 5:
  message = "Бесплатное место в университете тебе обеспечено!"
 default:
  message = "Переданы некорректные данные об оценке"
 }
 // вывод сообщения на консоль
 print(message)*/

//Диапазоны в операторе Switch

/*let userMark = 4
switch userMark {
case 1..<3:
 print("Экзамен не сдан")
case 3:
 print("Требуется решение дополнительного задания")
//10.3. Оператор ветвления switch   203
case 4...5:
 print("Экзамен сдан")
default:
 assert(false, "Указана некорректная оценка")
}
*/

//кортежи в операторе switch
let answer: (code: Int, message: String) = (code: 404, message: "Page not found")
/*switch answer {
case (100..<400, _):
 print( answer.message )
case (400..<500, _):
 assert( false, answer.message )
default:
 print( "Получен некорректный ответ" )
}*/

/**let dragonCharacteristics: (color: String, weight: Float) = ("красный", 1.4)
 switch dragonCharacteristics {
  case ("зеленый", 0..<2 ):
  print("Вольер № 1")
  case ("красный", 0..<2 ):
  print("Вольер № 2")
  case ("зеленый", 2...), ("красный", 2...):
  print("Вольер № 3")
  default:
  print("Дракон не может быть принят в стаю")
 }*/

//ключевое слово where в операторе switch

/*Представьте, что в задаче про вольеры для драконов появилось дополнительное
 условие: поместить дракона в вольер № 3 можно только при условии, что в нем
 находится менее пяти особей. Для хранения количества драконов будет использоваться дополнительная переменная.
 Включать в кортеж третий элемент и проверять его значение было бы неправильно с точки зрения логики, так как количество драконов не имеет ничего общего
 с характеристиками конкретного дракона.
 С одной стороны, данный функционал можно реализовать с помощью конструкции if-else внутри последнего case-блока, но наиболее правильным вариантом
 станет использование ключевого слова where, позволяющего указать дополнительные требования, в том числе к значениям внешних параметров*/
/*var dragonsCount = 3
switch dragonCharacteristics {
case ("зеленый", 0..<2 ):
 print("Вольер № 1")
case ("красный", 0..<2 ):
 print("Вольер № 2")
case ("зеленый", 2...) where dragonsCount < 5,
 ("красный", 2...) where dragonsCount < 5:
 print("Вольер № 3")
default:
 print("Дракон не может быть принят в стаю")
}
*/

//связываение значений
/*/
switch dragonCharacteristics {
case ("зеленый", 0..<2 ):
 print("Вольер № 1")
case ("красный", 0..<2 ):
 print("Вольер № 2")
case ("зеленый", 2...) where
 dragonCharacteristics.weight.truncatingRemainder(dividingBy: 1) == 0
 && dragonsCount < 5,
 ("красный", 2...) where
 dragonCharacteristics.weight.truncatingRemainder(dividingBy: 1) == 0
 && dragonsCount < 5:
 print("Вольер № 3")
default:
 print("Дракон не может быть принят в стаю")
}
 
 
 /*
*/Листинг 10.27
switch dragonCharacteristics {
case ("зеленый", 0..<2 ):
 print("Вольер № 1")
case ("красный", 0..<2 ):
 print("Вольер № 2")
case ("зеленый", let weight) where
 weight > 2
 && dragonsCount < 5,
10.3. Оператор ветвления switch   207
 ("красный", let weight) where
 weight > 2
 && dragonsCount < 5:
 print("Вольер № 3")
default:
 print("Дракон не может быть принят в стаю")
}
В заголовке case-блока для второго элемента кортежа вместо указания диапазона
используется связывание его значения с локальной константой weight. Данная
константа называется связанным параметром, она содержит связанное значение.
Обратите внимание, что проверка веса дракона (более двух тонн) перенесена
в where-условие.
После связывания значения данный параметр можно использовать не только
в where-условии, но и внутри тела case-блока (листинг 10.28).
Листинг 10.28
switch dragonCharacteristics {
case ("зеленый", 0..<2 ):
 print("Вольер № 1")
case ("красный", 0..<2 ):
 print("Вольер № 2")
case ("зеленый", let weight) where
 weight > 2
 && weight.truncatingRemainder(dividingBy: 1) == 0
 && dragonsCount < 5,
 ("красный", let weight) where
 weight > 2
 && weight.truncatingRemainder(dividingBy: 1) == 0
 && dragonsCount < 5:
 print("Вольер № 3. Вес дракона \(weight) тонны")
default:
 print("Дракон не может быть принят в стаю")
}
Можно сократить и упростить код, если объявить сразу два связанных параметра,
по одному для каждого элемента кортежа (листинг 10.29).
Листинг 10.29
switch dragonCharacteristics {
case ("зеленый", 0..<2 ):
 print("Вольер № 1")
case ("красный", 0..<2 ):
 print("Вольер № 2")
case let (color, weight) where
 (color == "зеленый" || color == "красный")
 && weight.truncatingRemainder(dividingBy: 1) == 0
 && dragonsCount < 5:
 print("Вольер № 3. Вес дракона \(weight) тонны")
default:
 print("Дракон не может быть принят в стаю")
}
*/


//оператор break в конструкции switch case

/*Если требуется, чтобы case-блок не имел исполняемого кода, то необходимо указать ключевое слово break, с помощью которого работа оператора switch будет
принудительно завершена.
Одним из типовых вариантов использования break является его определение
в блоке default, когда в нем не должно быть другого кода. Таким образом достигается избыточность, даже если в case не будет найдено необходимое значение,
конструкция завершит свою работу без ошибок, просто передав управление
в default-блок, где находится break.
В листинге 10.30 показан пример, в котором на консоль выводятся сообщения
в зависимости от того, является целое число положительным или отрицательным. При этом в случае, когда оно равняется нулю, оператор switch просто
завершает работу.
Листинг 10.30
let someInt = 12
switch someInt {
case 1...:
 print( "Больше 0" )
case ..<0:
 print( "Меньше 0" )
default:
 break
}*/


//Ключевое слово fallthrough


/*С помощью ключевого слова fallthrough можно изменить логику функционирования оператора switch и не прерывать его работу после выполнения кода в caseблоке. Данное ключевое слово позволяет перейти к телу последующего case-блока.
 Рассмотрим следующий пример: представьте, что существует три уровня готовности к чрезвычайным ситуациям: А, Б и В. Каждая степень предусматривает
 выполнение ряда мероприятий, причем каждый последующий уровень включает
 в себя мероприятия предыдущих уровней. Минимальный уровень — это В, максимальный — А (включает в себя мероприятия уровней В и Б).
 Реализуем программу, выводящую на консоль все мероприятия, соответствующие
 текущему уровню готовности к ЧС. Так как мероприятия повторяются от уровня
 к уровню, то можно реализовать задуманное с помощью оператора switch с использованием ключевого слова fallthrough (листинг 10.31).
 Листинг 10.31
 let level: Character = "Б"
 // определение уровня готовности
 switch level {
 10.4. Операторы повторения while и repeat while   209
  case "А":
  print("Выключить все электрические приборы ")
  fallthrough
  case "Б":
  print("Закрыть входные двери и окна ")
  fallthrough
  case "В":
  print("Соблюдать спокойствие")
  default:
  break
 }*/
