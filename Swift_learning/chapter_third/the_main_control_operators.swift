//
//  the_main_control_operators.swift
//  Swift_learning
//
//  Created by Даниил Асташов on 11.10.2024.
//

import Foundation

//утверждения
/*Swift позволяет прервать выполнение программы в случае, когда некоторое условие не выполняется: к примеру, если значение переменной отличается от требуемого. Для этого предназначен специальный механизм утверждений (assertions).
 Утверждения в Swift реализованы в виде глобальной функции assert(_:_:).*/
// утверждение с двумя аргументами
//assert( someVar > 100, "Данные неверны" )
// утверждение с одним аргументом
//assert( anotherVar <= 10 )

let strName = "Дракон"
let strYoung = "молод"
let strOld = "стар"
let strEmpty = " "
var dragonAge = 230
//assert( dragonAge <= 235, strName+strEmpty+strOld )
//assert( dragonAge >= 225, strName+strEmpty+strYoung )
//print("Программа успешно завершила свою работу")


var dragonAge_new = 220
//assert( dragonAge_new <= 235, strName+strEmpty+strOld )
//assert( dragonAge_new >= 225, strName+strEmpty+strYoung )
//print("Программа успешно завершила свою работу")
//Консоль
//Assertion failed: Дракон молод


//опрератор if

/*Оператор условия if имеет четыре формы записи, различающиеся по синтаксису
 и функциональным возможностям:
  сокращенная;
  стандартная;
  расширенная;
  тернарная*/

//сокращенный синтаксис
/*if userName == "Alex" {
 print("Привет, администратор")
}*/

// переменная типа Bool
var logicVar = true
// проверка значения переменной
//10.2. Оператор условия if   191
/*if logicVar == true {
 print("Переменная logicVar истинна")
}*/

/*if logicVar {
 print("Переменная logicVar истинна")
}*/

/*logicVar = false
if logicVar {
 print("Переменная logicVar истинна")
}
// вывод на консоли пуст
Swift — это язык со строгой типизацией. Любое проверяемое выражение обязательно должно возвращать либо true, либо false, и никак иначе. По этой причине если оно возвращает значение другого типа, то Xcode сообщит об ошибке
(листинг 10.6).
Листинг 10.6
var intVar = 1
if intVar { // ОШИБКА
}
*/

//стандартный синтаксис опреатора if

/*if userName == "Alex" {
 print("Привет, администратор")
} else {
 print("Привет, пользователь")
}*/

/*// переменная типа Bool
 var logicVar = false
 // проверка значения переменной
 if logicVar {
  print("Переменная logicVar истинна")
 } else {
  print("Переменная logicVar ложна")
 }*/

//расширенный синтаксис оператора if
/*/
if userName == "Alex" {
 print("Привет, администратор")
} else if userName == "Bazil" {
 print("Привет, модератор")
} else if userName == "Helga"{
 print("Привет, редактор")
} else {
 print("Привет, пользователь")
}
*/




/*
if (..<5).contains(tenantCount) {
 rentPrice = 1000
} else if (5...7).contains(tenantCount) {
 rentPrice = 800
} else if (8...).contains(tenantCount) {
 rentPrice = 500
}
*/


//тернарный опрератор условия

/*Swift позволяет значительно упростить стандартную форму записи оператора if всего до нескольких символов. Данная форма называется тернарным
 оператором условия. Его отличительной особенностью является то, что он не
 просто выполняет соответствующее выражение, но и возвращает результат его
 работы.*/


/*проверяемое_выражение ? выражение_1 : выражение_2
 проверяемое_выражение -> Bool — вычисляемое выражение, на основании значения
 которого принимается решение об исполнении кода, находящегося в блоке.
 выражение_1 -> Any — выражение, значение которого будет возвращено, если проверяемое
 выражение вернет true.
 выражение_2 -> Any — выражение, значение которого будет возвращено, если проверяемое
 выражение вернет false.
 При истинности проверяемого выражения выполняется первый блок кода. В ином случае
 выполняется второй блок. При этом тернарный оператор не просто выполняет код в блоке,
 но возвращает значение из него.*/

var x = 44
let y = ( x > 100 ? 100 : 50 )


let a = 1
let b = 2
// сравнение значений констант
//a <= b ? print("A меньше или равно B") : print("A больше B")


/*// переменная типа Int
 var height = 180
 // переменная типа Bool
 var isHeader = true
 // вычисление значения константы
 let rowHeight = height + (isHeader ? 20 : 10 )
 // вывод значения переменной
 rowHeight // 200*/

/**ПРИМЕЧАНИЕ Отдельные выражения внутри проверяемого выражения могут быть отделены
 не только логическими операторами || и &&, но и с помощью запятой (,). Она с логической
 точки зрения работает как &&, то есть если одно из условий false, то общий результат проверки также будет false.
 let a = Int.random(in: 1...100)
 let b = Int.random(in: 1...100)
 // вариант 1 (с И)
 if a > 50 && b > 50 {
  print("a and b > 50")
 }
 // вариант 2 (c запятой)
 if a > 50, b > 50 {
  print("a and b > 50")
 }
 При этом использование запятой имеет несколько особенностей:
 • Вычисление значения выражений происходит по порядку, и если одно из выражений не
 истинно (false), то последующие подвыражения вычисляться не будут.
 • Результаты вычисления каждого подвыражения могут быть использованы в последующих
 подвыражениях.
 В следующем примере используются опционалы, изучению которых будет посвящена следующая
 глава. В нем результаты вычислений первого и второго подвыражений используются в третьем/
if let a = Int("43"), let b = Int("45"), a < b {
 print("a < b")
}*/


//оператор ветвления SWITCH

/*Нередки случаи, когда приходится работать с большим количеством вариантов
 значений вычисляемого выражения, и для каждого из возможных значений необходимо выполнить определенный код. Для этого можно использовать расширенный синтаксис оператора if, многократно повторяя блоки else if.
 Предположим, что в зависимости от полученной пользователем оценки стоит
 задача вывести определенный текст. Реализуем логику с использованием оператора if (листинг 10.19)*/

// оценка
let userMark = 4
/*if userMark == 1 {
 print("Единица на экзамене! Это ужасно!")
} else if userMark == 2 {
 print("С двойкой ты останешься на второй год!")
} else if userMark == 3 {
 print("Ты плохо учил материал в этом году!")
} else if userMark == 4 {
 print("Неплохо, но могло быть и лучше")
} else if userMark == 5 {
 print("Бесплатное место в университете тебе обеспечено!")
} else {
 print("Переданы некорректные данные об оценке")
}*/

/*switch userMark {
 case 1,2:
 print("Экзамен не сдан")
 case 3:
 print("Необходимо выполнить дополнительное задание")
 case 4,5:
 print("Экзамен сдан")
 default:
 print("Указана некорректная оценка")
}
*/

/*let userMark = 4
 // переменная для хранения сообщения
 let message: String
 202   Глава 10. Операторы управления
 switch userMark {
 case 1:
  message = "Единица на экзамене! Это ужасно!"
 case 2:
  message = "С двойкой ты останешься на второй год!"
 case 3:
  message = "Ты плохо учил материал в этом году!"
 case 4:
  message = "Неплохо, но могло быть и лучше"
 case 5:
  message = "Бесплатное место в университете тебе обеспечено!"
 default:
  message = "Переданы некорректные данные об оценке"
 }
 // вывод сообщения на консоль
 print(message)*/

//Диапазоны в операторе Switch

/*let userMark = 4
switch userMark {
case 1..<3:
 print("Экзамен не сдан")
case 3:
 print("Требуется решение дополнительного задания")
//10.3. Оператор ветвления switch   203
case 4...5:
 print("Экзамен сдан")
default:
 assert(false, "Указана некорректная оценка")
}
*/

//кортежи в операторе switch
let answer: (code: Int, message: String) = (code: 404, message: "Page not found")
/*switch answer {
case (100..<400, _):
 print( answer.message )
case (400..<500, _):
 assert( false, answer.message )
default:
 print( "Получен некорректный ответ" )
}*/

/**let dragonCharacteristics: (color: String, weight: Float) = ("красный", 1.4)
 switch dragonCharacteristics {
  case ("зеленый", 0..<2 ):
  print("Вольер № 1")
  case ("красный", 0..<2 ):
  print("Вольер № 2")
  case ("зеленый", 2...), ("красный", 2...):
  print("Вольер № 3")
  default:
  print("Дракон не может быть принят в стаю")
 }*/

//ключевое слово where в операторе switch

/*Представьте, что в задаче про вольеры для драконов появилось дополнительное
 условие: поместить дракона в вольер № 3 можно только при условии, что в нем
 находится менее пяти особей. Для хранения количества драконов будет использоваться дополнительная переменная.
 Включать в кортеж третий элемент и проверять его значение было бы неправильно с точки зрения логики, так как количество драконов не имеет ничего общего
 с характеристиками конкретного дракона.
 С одной стороны, данный функционал можно реализовать с помощью конструкции if-else внутри последнего case-блока, но наиболее правильным вариантом
 станет использование ключевого слова where, позволяющего указать дополнительные требования, в том числе к значениям внешних параметров*/
/*var dragonsCount = 3
switch dragonCharacteristics {
case ("зеленый", 0..<2 ):
 print("Вольер № 1")
case ("красный", 0..<2 ):
 print("Вольер № 2")
case ("зеленый", 2...) where dragonsCount < 5,
 ("красный", 2...) where dragonsCount < 5:
 print("Вольер № 3")
default:
 print("Дракон не может быть принят в стаю")
}
*/

//связываение значений
/*/
switch dragonCharacteristics {
case ("зеленый", 0..<2 ):
 print("Вольер № 1")
case ("красный", 0..<2 ):
 print("Вольер № 2")
case ("зеленый", 2...) where
 dragonCharacteristics.weight.truncatingRemainder(dividingBy: 1) == 0
 && dragonsCount < 5,
 ("красный", 2...) where
 dragonCharacteristics.weight.truncatingRemainder(dividingBy: 1) == 0
 && dragonsCount < 5:
 print("Вольер № 3")
default:
 print("Дракон не может быть принят в стаю")
}
 
 
 /*
*/Листинг 10.27
switch dragonCharacteristics {
case ("зеленый", 0..<2 ):
 print("Вольер № 1")
case ("красный", 0..<2 ):
 print("Вольер № 2")
case ("зеленый", let weight) where
 weight > 2
 && dragonsCount < 5,
10.3. Оператор ветвления switch   207
 ("красный", let weight) where
 weight > 2
 && dragonsCount < 5:
 print("Вольер № 3")
default:
 print("Дракон не может быть принят в стаю")
}
В заголовке case-блока для второго элемента кортежа вместо указания диапазона
используется связывание его значения с локальной константой weight. Данная
константа называется связанным параметром, она содержит связанное значение.
Обратите внимание, что проверка веса дракона (более двух тонн) перенесена
в where-условие.
После связывания значения данный параметр можно использовать не только
в where-условии, но и внутри тела case-блока (листинг 10.28).
Листинг 10.28
switch dragonCharacteristics {
case ("зеленый", 0..<2 ):
 print("Вольер № 1")
case ("красный", 0..<2 ):
 print("Вольер № 2")
case ("зеленый", let weight) where
 weight > 2
 && weight.truncatingRemainder(dividingBy: 1) == 0
 && dragonsCount < 5,
 ("красный", let weight) where
 weight > 2
 && weight.truncatingRemainder(dividingBy: 1) == 0
 && dragonsCount < 5:
 print("Вольер № 3. Вес дракона \(weight) тонны")
default:
 print("Дракон не может быть принят в стаю")
}
Можно сократить и упростить код, если объявить сразу два связанных параметра,
по одному для каждого элемента кортежа (листинг 10.29).
Листинг 10.29
switch dragonCharacteristics {
case ("зеленый", 0..<2 ):
 print("Вольер № 1")
case ("красный", 0..<2 ):
 print("Вольер № 2")
case let (color, weight) where
 (color == "зеленый" || color == "красный")
 && weight.truncatingRemainder(dividingBy: 1) == 0
 && dragonsCount < 5:
 print("Вольер № 3. Вес дракона \(weight) тонны")
default:
 print("Дракон не может быть принят в стаю")
}
*/


//оператор break в конструкции switch case

/*Если требуется, чтобы case-блок не имел исполняемого кода, то необходимо указать ключевое слово break, с помощью которого работа оператора switch будет
принудительно завершена.
Одним из типовых вариантов использования break является его определение
в блоке default, когда в нем не должно быть другого кода. Таким образом достигается избыточность, даже если в case не будет найдено необходимое значение,
конструкция завершит свою работу без ошибок, просто передав управление
в default-блок, где находится break.
В листинге 10.30 показан пример, в котором на консоль выводятся сообщения
в зависимости от того, является целое число положительным или отрицательным. При этом в случае, когда оно равняется нулю, оператор switch просто
завершает работу.
Листинг 10.30
let someInt = 12
switch someInt {
case 1...:
 print( "Больше 0" )
case ..<0:
 print( "Меньше 0" )
default:
 break
}*/


//Ключевое слово fallthrough


/*С помощью ключевого слова fallthrough можно изменить логику функционирования оператора switch и не прерывать его работу после выполнения кода в caseблоке. Данное ключевое слово позволяет перейти к телу последующего case-блока.
 Рассмотрим следующий пример: представьте, что существует три уровня готовности к чрезвычайным ситуациям: А, Б и В. Каждая степень предусматривает
 выполнение ряда мероприятий, причем каждый последующий уровень включает
 в себя мероприятия предыдущих уровней. Минимальный уровень — это В, максимальный — А (включает в себя мероприятия уровней В и Б).
 Реализуем программу, выводящую на консоль все мероприятия, соответствующие
 текущему уровню готовности к ЧС. Так как мероприятия повторяются от уровня
 к уровню, то можно реализовать задуманное с помощью оператора switch с использованием ключевого слова fallthrough (листинг 10.31).
 Листинг 10.31
 let level: Character = "Б"
 // определение уровня готовности
 switch level {
 10.4. Операторы повторения while и repeat while   209
  case "А":
  print("Выключить все электрические приборы ")
  fallthrough
  case "Б":
  print("Закрыть входные двери и окна ")
  fallthrough
  case "В":
  print("Соблюдать спокойствие")
  default:
  break
 }*/


//операторы while и repeat while

/*Рассмотрим пример использования оператора while. Произведем с его помощью
 сложение всех чисел от 1 до 10 (листинг 10.32).
 Листинг 10.32
 // начальное значение
 var i = 1
 // хранилище результата сложения
 var resultSum = 0
 // цикл для подсчета суммы
 while i <= 10 {
  resultSum += i
  i += 1
 }
 resultSum // 55
 Переменная i является счетчиком в данном цикле. Основываясь на ее значении,
 оператором определяется необходимость выполнения кода в теле цикла. На каждой итерации значение i увеличивается на единицу, и как только оно достигает
 10, то условие, проверяемое оператором, возвращает false, после чего происходит
 выход из цикла.
 Оператор while — это цикл с предварительной проверкой условия, то есть вначале проверяется условие, а уже потом выполняется или не выполняется код тела
 оператора. Если условие вернет false уже при первой проверке, то код внутри
 оператора будет проигнорирован и не выполнен ни одного раза.*/

//оператор repeat while
// начальное значение
/*var y = 1
// хранилище результата сложения
var result = 0
// цикл для подсчета суммы
repeat {
 result += y
 y += 1
} while y <= 10
result // 55
*/

//использование оператора continue


/**Оператор continue предназначен для перехода к очередной итерации, игнорируя
 следующий за ним код. Если программа встречает continue, то она незамедлительно переходит к новой итерации.
 Код в листинге 10.34 производит сложение всех четных чисел в интервале от 1 до
 10. Для этого в каждой итерации производится проверка на четность (по значению
 остатка от деления на 2).
 Листинг 10.34
 var x = 0
 var sum = 0
 while x <= 10 {
  x += 1
  if x % 2 == 1 {
  continue
  }
  sum += x
 }
 sum // 30*/


//использование оператора break

/**Оператор break предназначен для досрочного завершения работы цикла, с ним
 мы уже встречались ранее. При этом весь последующий код в теле цикла игнорируется. В листинге 10.35 показано, как производится подсчет суммы всех чисел
 от 1 до 54. При этом если сумма достигает 450, то происходит выход из оператора
 и выводится соответствующее сообщение.
 Листинг 10.35
 let lastNum = 54
 var currentNum = 1
 var sumOfInts = 0
 212   Глава 10. Операторы управления
 while currentNum <= lastNum {
  sumOfInts += currentNum
  if sumOfInts > 450 {
  print("Хранилище заполнено. Последнее обработанное
  число - \(currentNum)")
  break
  }
  currentNum += 1
 }
 Консоль
 Хранилище заполнено. Последнее обработанное число — 30*/


//оператор повроторения for

/*for oneElementOfArray in [1,3,5,7,9] {
 // тело оператора
}
10.5. Оператор повторения for   213
В листинге 10.36 показан пример использования оператора for, в котором производится подсчет суммы всех элементов массива, состоящего из целочисленных
значений.
Листинг 10.36
// массив целых чисел
let numArray: Array<Int> = [1, 2, 3, 4, 5]
// в данной переменной будет храниться
// сумма элементов массива numArray
var result: Int = 0
// цикл подсчета суммы
for number in numArray {
 result += number
}
result // 15
*/

/**for number in 1...5 {
 print(number)
}*/

/*for number in "Swift" {
 print(number)
}*/


/** // внешняя переменная
var myChar = "a"
// внешняя константа
let myString = "Swift"
// цикл использует связанный параметр с именем,
// уже используемым глобальной переменной
for myChar in myString {
 // локальная константа
 // вне цикла уже существует константа с таким именем
 let myString = "Char is"
 print("\(myString) \(myChar)")
}
myChar // "a"
myString // Swift
Консоль
Char is S
Char is w
Char is i
Char is f
Char is t */


/**for _ in 1...3 {
 print("Повторяющаяся строка")
}
Консоль
Повторяющаяся строка
Повторяющаяся строка
Повторяющаяся строка
 
 
 var countriesAndBlocks = ["Россия": "СНГ", "Франция": "ЕС"]
 for (countryName, orgName) in countriesAndBlocks {
  print("\(countryName) вступила в \(orgName)")
 }
 Консоль
 Франция вступила в ЕС
 Россия вступила в СНГ
 
 
 var countriesAndBlocks = ["Россия": "СНГ", "Франция": "ЕС"]
 for (countryName, _) in countriesAndBlocks {
  print("страна — \(countryName)")
 }
 for (_, orgName) in countriesAndBlocks{
  print("организация — \(orgName)")
 }
 Помимо этого, в случае, если требуется получить последовательность, состоящую
 только из ключей или значений словаря, можно воспользоваться свойствами keys
 и values — и передать результат их работы в оператор for (листинг 10.43).
 Листинг 10.43
 countriesAndBlocks = ["Россия": "ЕАЭС", "Франция": "ЕС"]
 for countryName in countriesAndBlocks.keys {
  print("страна — \(countryName)")
 }
 for orgName in countriesAndBlocks.values {
  print("организация — \(orgName)")
 }
 Если при работе с массивом для каждого элемента помимо значения требуется
 получить и индекс, то можно воспользоваться методом enumerated(), возвращающим последовательность кортежей, где первый элемент — индекс, а второй —
 значение (листинг 10.44).
 Листинг 10.44
 print("Несколько фактов обо мне:")
 let myMusicStyles = ["Rock", "Jazz", "Pop"]
 for (index, musicName) in myMusicStyles.enumerated() {
  print("\(index+1). Я люблю \(musicName)")
 }
 
 
 Если диапазон чисел будет не таким маленьким, а значительно шире (например,
 от 1 до 1000 с шагом 5), то самостоятельно описать его будет затруднительно. Также возможна ситуация, когда характеристики множества (начальное и конечное
 значение, а также шаг) заранее могут быть неизвестны. В этом случае удобнее
 всего воспользоваться специальными функциями stride(from:through:by:) или
 stride(from:to:by:), формирующими последовательность (Sequence) элементов
 на основе указанных правил.
 Функция stride(from:through:by:) возвращает последовательность числовых
 элементов, начиная с from до through с шагом by (листинг 10.46).
 Листинг 10.46
 for i in stride( from: 1, through: 10, by: 3 ) {
  // тело оператора
 }
 Параметр i будет последовательно принимать значения 1, 4, 7, 10.
 Функция stride(from:to:by:) имеет лишь одно отличие — вместо входного параметра through используется to, который исключает указанное в нем значение
 из последовательности (листинг 10.47).
 Листинг 10.47
 for i in stride( from: 1, to: 10, by:3 ) {
  // тело оператора
 }
 Параметр i будет получать значения 1, 4 и 7.
 В листинге 10.48 приведен пример вычисления суммы всех нечетных чисел от
 1 до 1000 с помощью функции stride(from:through:by:).
 10.5. Оператор повторения for   217
 Листинг 10.48
 var result = 0
 for i in stride( from: 1, through: 1000, by:2 ) {
  result += i
 }
 result // 250000*/


//использование where в конструкции for-in

/*Одной из замечательных возможностей оператора for является использование
 ключевого слова where для указания дополнительных условий итерации элементов
 последовательности.
 Вернемся к примеру подсчета суммы всех четных чисел от 1 до 10. Для этой цели
 можно использовать оператор for совместно с where-условием (листинг 10.49).
 Листинг 10.49
 var result = 0
 for i in 1...10 where i % 2 == 0 {
  result += i
 }
 result // 30
 После where указано условие, в котором определено, что код в теле оператора будет
 исполняться только в случае, когда остаток от деления связанного параметра i
 на 2 равен 0 (то есть число четное).
 Также с помощью where можно уйти от использования вложенных друг в друга
 операторов (например, for в if). В листинге 10.50 показаны два блока: первый
 с использованием двух операторов, а второй с использованием for и where. При
 этом обе конструкции функционально идентичны.
 Листинг 10.50
 var isRun = true
 // вариант 1
 if isRun {
  for i in 1...10 {
 218   Глава 10. Операторы управления
  // тело оператора
  }
 }
 // вариант 2
 for i in 1...10 where isRun {
  // тело оператора
 }
 
 В обоих вариантах код тела оператора будет выполнен 10 раз при условии, что
 isRun истинно, но при этом вариант № 2 более читабельный.*/

//многомерный коллекции в конструкции for-in
