//
//  closure.swift
//  Swift_learning
//
//  Created by Даниил Асташов on 20.10.2024.
//

import Foundation


/**Как объясняется в документации к языку Swift, замыкания (closures) — это
 организованные блоки с определенной функциональностью, которые могут быть
 переданы и использованы в коде.
 Согласитесь, не очень доступное объяснение. Попробуем иначе.
 Замыкания (closure), или замыкающие выражения, — это сгруппированный
 программный код, который может быть передан в виде параметра и многократно
 использован. Ничего не напоминает? Если вы скажете, что в этом определении
 узнали функции, то будете полностью правы. Поговорим об этом подробнее*/

//виды замыканий

/*Как объясняется в документации к языку Swift, замыкания (closures) — это
 организованные блоки с определенной функциональностью, которые могут быть
 переданы и использованы в коде.
 Согласитесь, не очень доступное объяснение. Попробуем иначе.
 Замыкания (closure), или замыкающие выражения, — это сгруппированный
 программный код, который может быть передан в виде параметра и многократно
 использован. Ничего не напоминает? Если вы скажете, что в этом определении
 узнали функции, то будете полностью правы. Поговорим об этом подробнее.
 13.1. Виды замыканий
 Как вы знаете, параметры предназначены для хранения информации, а функции
 могут выполнять определенные задачи. Говоря простым языком, с помощью замыканий вы можете поместить блок исполняемого кода в переменную или константу, свободно передавать ее и при необходимости вызывать хранящийся в ней
 код. Вы уже видели подобный подход при изучении функций, и в этом нет ничего
 странного. Дело в том, что функции — это частный случай замыканий.
 В общем случае замыкание (closure) может принять две формы:
  именованная функция;
  безымянная функция, определенная с помощью облегченного синтаксиса.
 Знакомству с именованными функциями была посвящена вся предыдущая глава.
 Уверен, что вы уже неплохо знакомы с их возможностями. Далее рассмотрим
 безымянные функции как один из способов представления замыканий.
 ПРИМЕЧАНИЕ В дальнейшем безымянные функции будут именоваться замыканиями, или
 замыкающими выражениями. Говоря о функции, мы будем иметь в виду именно функции, а говоря о замыканиях — безымянные функции.*/

//введение в безымянные функции

/*Как вы уже знаете, переменная и константа может хранить в себе ссылку на
 функцию. Но для того, чтобы организовать это, не обязательно возвращать одну
 262   Глава 13. Замыкания (closure)
 функцию из другой. Вы можете использовать специальный облегченный синтаксис, создав безымянную функцию, после чего передать ее в качестве значения
 в требуемый параметр. Безымянные функции не имеют имен. Они состоят только
 из тела, заключенного в фигурные скобки.
 
 { (входные_параметры) -> ТипВозвращаемогоЗначения in
  // тело замыкающего выражения
 }
 */

// безымянная функция в качестве значения константы
let functionInLet = { return true }
// вызываем безымянную функцию
//functionInLet() // true

/**В нашей программе объявлена переменная wallet, хранящая в себе программный
 аналог кошелька с купюрами (в предыдущей главе мы уже использовали подобный массив-кошелек). Каждый элемент этой коллекции представляет собой
 одну банкноту определенного номинала. Перед нами стоит задача отбора банкнот
 в кошельке по различным условиям. Для каждого условия может быть создана
 отдельная функция, принимающая на вход массив wallet и возвращающая отфильтрованную коллекцию.
 В листинге 13.1 показано, каким образом может быть реализована функция отбора
 всех сторублевых купюр.*/

// массив с купюрами
var wallet = [10,50,100,100,5000,100,50,50,500,100]
// функция отбора купюр
func handle100(wallet: [Int]) -> [Int] {
    var returnWallet = [Int]()
    for banknote in wallet {
        if banknote == 100 {
            returnWallet.append(banknote)
        }
    }
    return returnWallet
}
// вызов функции отбора купюр с достоинством 100
//handle100(wallet: wallet) // [100, 100, 100, 100]
