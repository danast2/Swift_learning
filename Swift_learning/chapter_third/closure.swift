//
//  closure.swift
//  Swift_learning
//
//  Created by Даниил Асташов on 20.10.2024.
//

import Foundation


/**Как объясняется в документации к языку Swift, замыкания (closures) — это
 организованные блоки с определенной функциональностью, которые могут быть
 переданы и использованы в коде.
 Согласитесь, не очень доступное объяснение. Попробуем иначе.
 Замыкания (closure), или замыкающие выражения, — это сгруппированный
 программный код, который может быть передан в виде параметра и многократно
 использован. Ничего не напоминает? Если вы скажете, что в этом определении
 узнали функции, то будете полностью правы. Поговорим об этом подробнее*/

//виды замыканий

/*Как объясняется в документации к языку Swift, замыкания (closures) — это
 организованные блоки с определенной функциональностью, которые могут быть
 переданы и использованы в коде.
 Согласитесь, не очень доступное объяснение. Попробуем иначе.
 Замыкания (closure), или замыкающие выражения, — это сгруппированный
 программный код, который может быть передан в виде параметра и многократно
 использован. Ничего не напоминает? Если вы скажете, что в этом определении
 узнали функции, то будете полностью правы. Поговорим об этом подробнее.
 13.1. Виды замыканий
 Как вы знаете, параметры предназначены для хранения информации, а функции
 могут выполнять определенные задачи. Говоря простым языком, с помощью замыканий вы можете поместить блок исполняемого кода в переменную или константу, свободно передавать ее и при необходимости вызывать хранящийся в ней
 код. Вы уже видели подобный подход при изучении функций, и в этом нет ничего
 странного. Дело в том, что функции — это частный случай замыканий.
 В общем случае замыкание (closure) может принять две формы:
  именованная функция;
  безымянная функция, определенная с помощью облегченного синтаксиса.
 Знакомству с именованными функциями была посвящена вся предыдущая глава.
 Уверен, что вы уже неплохо знакомы с их возможностями. Далее рассмотрим
 безымянные функции как один из способов представления замыканий.
 ПРИМЕЧАНИЕ В дальнейшем безымянные функции будут именоваться замыканиями, или
 замыкающими выражениями. Говоря о функции, мы будем иметь в виду именно функции, а говоря о замыканиях — безымянные функции.*/

//введение в безымянные функции

/*Как вы уже знаете, переменная и константа может хранить в себе ссылку на
 функцию. Но для того, чтобы организовать это, не обязательно возвращать одну
 262   Глава 13. Замыкания (closure)
 функцию из другой. Вы можете использовать специальный облегченный синтаксис, создав безымянную функцию, после чего передать ее в качестве значения
 в требуемый параметр. Безымянные функции не имеют имен. Они состоят только
 из тела, заключенного в фигурные скобки.
 
 { (входные_параметры) -> ТипВозвращаемогоЗначения in
  // тело замыкающего выражения
 }
 */

// безымянная функция в качестве значения константы
let functionInLet = { return true }
// вызываем безымянную функцию
//functionInLet() // true

/**В нашей программе объявлена переменная wallet, хранящая в себе программный
 аналог кошелька с купюрами (в предыдущей главе мы уже использовали подобный массив-кошелек). Каждый элемент этой коллекции представляет собой
 одну банкноту определенного номинала. Перед нами стоит задача отбора банкнот
 в кошельке по различным условиям. Для каждого условия может быть создана
 отдельная функция, принимающая на вход массив wallet и возвращающая отфильтрованную коллекцию.
 В листинге 13.1 показано, каким образом может быть реализована функция отбора
 всех сторублевых купюр.*/

// массив с купюрами
var wallet = [10,50,100,100,5000,100,50,50,500,100]
// функция отбора купюр
func handle100(wallet: [Int]) -> [Int] {
    var returnWallet = [Int]()
    for banknote in wallet {
        if banknote == 100 {
            returnWallet.append(banknote)
        }
    }
    return returnWallet
}
// вызов функции отбора купюр с достоинством 100
//handle100(wallet: wallet) // [100, 100, 100, 100]

/**При каждом вызове функция handle100(wallet:) будет возвращать массив сторублевых купюр переданного массива-кошелька.
 Но условия отбора не ограничиваются данной функцией. Расширим функционал
 нашей программы, написав дополнительную функцию для отбора купюр достоинством 1000 рублей и более (листинг 13.2).*/

func handleMore1000(wallet: [Int]) -> [Int] {
    var returnWallet = [Int]()
    for banknote in wallet {
        if banknote >= 1000 {
            returnWallet.append(banknote)
        }
}
    return returnWallet
}
// вызов функции отбора купюр с достоинством более или равно 1000
//handleMore1000(wallet: wallet) // [5000]

/**В результате для отбора купюр по требуемым условиям реализовано уже две
 функции: handle100(wallet:) и handleMore1000(wallet:). При этом тела обеих
 функций очень похожи (практически дублируют друг друга), разница лишь в проверяемом условии, остальной код в функциях один и тот же. В случае дальнейшего
 расширения программы будут появляться все новые и новые функции, также
 повторяющие один и тот же код.
 Для решения проблемы дублирования можно пойти двумя путями:
  реализовать всю функциональность отбора купюр в пределах одной функции,
 а в качестве аргумента передавать условие;
  реализовать всю функциональность в виде трех функций. Первая будет группировать повторяющийся код и принимать в виде аргумента одну из двух
 других функций. Переданная функция будет производить проверку условия
 в теле главной функции.*/

/**функция будет разрастаться и в конце концов станет нечитабельной и слишком
 264   Глава 13. Замыкания (closure)
 сложной. Плюс к этому необходимо придумать, каким образом передавать указатель на проверяемое условие, а значит, потребуется вести документацию к данной
 функции.
 По этой причине воспользуемся вторым вариантом, реализуем функционал в виде
 трех функций:
  Функция с именем handle, принимающая массив-кошелек и условие отбора
 (в виде имени функции) в качестве аргументов и возвращающая массив отобранных купюр. В теле функции будут поочередно проверяться элементы
 входного массива на соответствие переданному условию.
  Функция с именем compare100, принимающая на вход значение очередного
 элемента массива-кошелька, производящая сравнение с целым числом 100
 и возвращающая логический результат этой проверки.
  Функция с именем compareMore1000, аналогичная compare100, но производящая
 проверку на соответствие целому числу 1000.
 В листинге 13.3 показана реализация описанного алгоритма*/

// единая функция формирования результирующего массива
func handle(wallet: [Int], closure: (Int) -> Bool) -> [Int] {
 var returnWallet = [Int]()
 for banknote in wallet {
     if closure(banknote) {
         returnWallet.append(banknote)
     }
}
 return returnWallet
}
// функция сравнения с числом 100
func compare100(banknote: Int) -> Bool {
    return banknote == 100
}
// функция сравнения с числом 1000
func compareMore1000(banknote:Int) -> Bool {
    return banknote >= 1000
}
// отбор
let resultWalletOne = handle(wallet: wallet, closure: compare100)
let resultWalletTwo = handle(wallet: wallet, closure: compareMore1000)

/**Функция handle(wallet:closure:) получает в качестве входного параметра
 closure одну из функций проверки условия и в операторе if вызывает переданную функцию. Функции проверки принимают на вход анализируемую купюру и возвращают Bool в зависимости от результата сравнения. Чтобы получить купюры определенного достоинства, необходимо вызвать функцию
 handle(wallet:closure:) и передать в нее имя одной из функций проверки.
 В итоге мы получили очень качественный и легкочитаемый код.
 13.3. Возможности замыканий   265
 Представим, что возникла необходимость написать функции для отбора купюр по
 многим и многим условиям (найти все полтинники; все купюры достоинством менее 1000 рублей; все купюры, которые без остатка делятся на 200, и т. д.). Условий
 отбора может быть великое множество. В определенный момент писать отдельную
 функцию проверки для каждого из них станет довольно тяжелой задачей, так как
 для того, чтобы использовать единую функцию проверки, необходимо знать имя
 проверяющей функции, а их могут быть десятки.
 В подобной ситуации можно отказаться от создания отдельных функций и передавать в handle(wallet:closure:) условие отбора в виде безымянной функции.
 В листинге 13.4 показано, каким образом это может быть реализовано.*/
