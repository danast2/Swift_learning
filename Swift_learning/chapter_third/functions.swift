//
//  functions.swift
//  Swift_learning
//
//  Created by Даниил Асташов on 17.10.2024.
//

import Foundation

func myFirstFunc(a: Int, b: String) -> String {
 String(a) + b
}
func printMessage() {
 print("Сообщение принято")
}
// вызываем функцию по ее имени
//printMessage()
//printMessage()


func sumTwoInt(a: Int, b: Int) {
 print("Результат операции - \(a+b)")
}

/*Внешние имена входных параметров
Аргументы a и b функции sumTwoInt(a:b:) используются как при вызове функции,
так и в ее теле (там они называются входными параметрами). Swift позволяет
указать внешние имена параметров, которые будут использоваться при вызове
функции (листинг 12.3).*/
func sumTwoInt(num1 a: Int, num2 b: Int) {
 print("Результат операции - \(a+b)")
}
//sumTwoInt(num1: 10, num2: 12)

//Если внешнее имя заменить на символ нижнего подчеркивания (_), то при вызове
//функции имя параметра вообще не потребуется указывать (листинг 12.4).
//Листинг 12.4
func sumTwoInt(_ a: Int, _ b: Int) {
 print("Результат операции - \(a+b)")
}

//sumTwoInt(10, 12) //22

func sumTwoInt_new(_ a: Int, _ b: Int) -> Int {
 let result = a + b
 print("Результат операции - \(result)")
 return result
}
var result = sumTwoInt_new(10, 12) // 22

/**Изменяемые копии входных параметров
 Все входные параметры функции — константы. При попытке изменения их значения внутри тела функции происходит ошибка. При необходимости изменения
 переданного входного значения внутри функции потребуется создать новую
 переменную и присвоить переданное значение ей (листинг 12.6).*/

func returnMessage(code: Int, message: String) -> String {
 var mutableMessage = message
 mutableMessage += String(code)
 return mutableMessage
}
let myMessage = returnMessage(code: 200, message: "Код сообщения - ")
//Функция returnMessage(code:message:) получает на вход два аргумента: code
//и message. В ее теле создается изменяемая копия message, которая без каких-либо
//ошибок модифицируется, после чего возвращается

/**Сквозные параметры
 Приведенный способ модификации значений параметров позволяет получать доступ
 к изменяемому значению только в пределах тела самой функции. Для того чтобы
 была возможность модификации параметров с сохранением измененных значений
 после окончания работы функции, необходимо использовать сквозные параметры.
 Чтобы преобразовать входной параметр в сквозной, перед описанием его типа необходимо указать модификатор inout. Сквозной параметр передается в функцию,
 изменяется в ней и сохраняет свое значение при завершении работы функции,
 заменяя собой исходное значение. При вызове функции перед передаваемым
 значением аргумента необходимо ставить символ «амперсанд» (&), указывающий
 на то, что параметр передается по ссылке.
 Функция в листинге 12.7 обеспечивает обмен значениями двух внешних параметров.*/

func changeValues(_ a: inout Int, _ b: inout Int) -> Void {
 let tmp = a
 a = b
 b = tmp
}
var x_new = 150, y_new = 45
//changeValues(&x, &y)
//x // 45
//y // 150

//Функция принимает на входе две переменные, a и b. Эти переменные передаются
//в функцию как сквозные параметры, что позволяет изменить их значения внутри
//функции и сохранить эти изменения после завершения ее работы.
//ПРИМЕЧАНИЕ В качестве сквозного параметра может выступать только переменная. Константы или литералы нельзя передавать, так как они являются неизменяемыми.

//функция в качестве входного параметра

/*Вы можете использовать возвращаемое некоторой функцией значение в качестве
 значения входного параметра другой функции. Самое важное, чтобы тип возвращаемого значения функции совпадал с типом входного параметра.
 В листинге 12.8 используется объявленная ранее функция returnMessage
 (code:message:), возвращающая значение типа String.
 Листинг 12.8
 // используем функцию в качестве значения
                                        print( returnMessage(code: 400, message: "Сервер недоступен. Код сообщения - ") )
 Консоль
 Сервер недоступен. Код сообщения - 400
 12.2. Входные параметры и возвращаемое значение   249
 Уже известная нам функция print(_:) принимает на входе строковый литерал
 типа String. Так как функция returnMessage(code:message:) возвращает значение
 этого типа, она может быть указана в качестве входного параметра для print(_:).*/

//Входной параметр с переменным числом значений

/*В некоторых ситуациях необходимо, чтобы функция получала неизвестное заранее число однотипных значений. Мы уже встречались с таким подходом при
использовании Array(arrayLiteral:), когда заранее неизвестно, сколько элементов будет содержать параметр arrayLiteral. Такой тип входного параметра
называется вариативным.
Вариативный параметр обозначается в списке входящих параметров с указанием
оператора диапазона ... сразу после типа. Значения аргумента при вызове функции задаются через запятую.
Рассмотрим пример из листинга 12.9. Представьте, что удаленный сервер на каждый запрос отправляет вам несколько ответов. Каждый ответ — это целое число,
но их количество может быть различным. Вам необходимо написать функцию,
которая принимает на входе все полученные ответы и выводит их на консоль.
Листинг 12.9*/
func printRequestString(codes: Int...) -> Void {
 var codesString = ""
 for oneCode in codes {
 codesString += String(oneCode) + " "
 }
 print("Получены ответы — \(codesString)")
}
/*printRequestString(codes: 600, 800, 301)
printRequestString(codes: 101, 200)
Консоль
Получены ответы — 600 800 301
Получены ответы — 101 200
Параметр codes может содержать произвольное количество значений указанного
типа. Внутри функции он трактуется как последовательность (Sequence), поэтому
его можно обработать с помощью конструкции for-in.
У одной функции может быть только один вариативный параметр, и он должен
находиться в самом конце списка входных параметров*/

//кортеж в качестве возвращаемого значения

/*Функция может возвращать значения любого типа данных. Отдельно отмечу,
 что и кортежи могут быть использованы для этого, так как с их помощью можно
 с легкостью вернуть сразу несколько значений (возможно, именно этого вам не
 хватало в других языках программирования, — лично мне не хватало).
 250   Глава 12. Функции
 Представленная в листинге 12.10 функция принимает на вход код ответа сервера
 и в зависимости от того, к какому диапазону относится переданный код, возвращает кортеж с его описанием*/

func getCodeDescription(code: Int) -> (Int, String) {
 let description: String
 switch code {
 case 1...100:
     description = "Error"
 case 101...200:
     description = "Correct"
 default:
     description = "Unknown"
 }
 return (code, description)
}
//getCodeDescription(code: 150) // (150, "Correct")

/**В качестве типа возвращаемого значения функции getCodeDescription(code:)
 указан тип кортежа, содержащего два значения: код и его описание.
 Функцию getCodeDescription(code:) можно улучшить, если указать не просто тип
 возвращаемого кортежа, а названия его элементов (прямо в типе возвращаемого
 функцией значения) (листинг 12.11).*/


func getCodeDescription_new(code: Int) -> (code: Int, description: String) {
 let description: String
 switch code {
 case 1...100:
     description = "Error"
 case 101...200:
     description = "Correct"
 default:
     description = "Unknown"
 }
 return (code, description)
}
let request_new = getCodeDescription_new(code: 45)
//request.description // "Error"
//request.code // 45
