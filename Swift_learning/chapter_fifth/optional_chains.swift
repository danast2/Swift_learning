//
//  optional_chains.swift
//  Swift_learning
//
//  Created by Даниил Асташов on 24.10.2024.
//

import Foundation


//Опционалы — очень полезный и важный элемент Swift, и если вы достаточно
//хорошо освоите его, то уже не сможете обойтись без него ни в одной программе.
//В этой главе мы поговорим об особенностях доступа к значениям объектных типов,
//которые являются опционалами, а также к их свойствам и методам.


//29.1. Доступ к свойствам через
//опциональные цепочки
//Рассмотрим пример из листинга 29.1. Перед вами два класса: Residence, описывающий сущность «Место жительства», и Person, описывающий «Персону».


class Person_n {
 // резиденция данной персоны
 var residence: Residence?
}
class Residence {
 // количество комнат в резиденции
 var rooms = 1
}


//Свойство residence в классе Person может содержать значение типа Residence
//(а может не содержать его, так как это опционал), но по умолчанию при создании
//нового экземпляра оно является nil (листинг 29.2).


//Листинг 29.2
//var man = Person()
//man.residence // nil
//В дальнейшем этому свойству может быть проинициализировано определенное значение, а позже оно может быть вновь удалено, и так многократно (листинг 29.3).
//29.1. Доступ к свойствам через опциональные цепочки   401
//Листинг 29.3
//man.residence = Residence()
//man.residence = nil
//Проблема в том, что в любой момент времени вы не можете точно знать, содержит
//ли свойство residence конкретное значение или находится ли в нем nil. Чтобы
//избежать ошибок доступа, необходимо проверить значение и только в случае его
//наличия проводить с ним операции. Например, это можно сделать с помощью
//опционального связывания (листинг 29.4).

/*
if let manResidence = man.residence {
 // действия с manResidence
}
*/

//Но что, если вложенность опциональных свойств окажется многоуровневой?
//В этом случае потребуется извлекать значение на каждом этапе, создавая вложенные друг в друга конструкции, что, в свою очередь, значительно усложнит
//навигацию по вашему коду. В качестве примера реализуем тип Room, описывающий
//сущность «Комната» (листинг 29.5). При этом укажем его в качестве типа данных
//свойства rooms в классе Residence.


class Person_v {
 var residence: Residence?
}
class Residenc_v {
 // перечень комнат в резиденции
 var rooms:[Room]?
}
struct Room {
 // площадь комнаты
 let square: Int
}
var man = Person_v()
// для доступа к значению типа Room
// необходимо выполнить два опциональных связывания
//if let residence = man.residence {
// if let rooms = residence.rooms {
// // действия с коллекцией типа [Room]
// }
//}


//ПРИМЕЧАНИЕ Обратите внимание, что свойство rooms класса Residence теперь является
//опциональной коллекцией. Ранее оно имело целочисленный тип данных и определяло количество комнат в резиденции.
//402   Глава 29. Опциональные цепочки
//Как видите, для доступа к свойству rooms и хранящейся в нем коллекции требуется строить вложенные конструкции опционального связывания. И чем сложнее
//будут ваши программы, тем более нагроможденным будет код.
//Для решения данной проблемы предназначены опциональные цепочки. Они позволяют в одном выражении написать полный путь к требуемому элементу, при
//этом после каждого опционала необходимо ставить знак вопроса (?).
//В листинге 29.6 показан пример доступа к свойству rooms с использованием опциональной цепочки


// создаем объект комната
let room = Room(square: 10)
// создаем объект место проживания
var residence = Residence()
// добавляем в него комнату
//residence.rooms = [room]
// создаем объект Персона
//var man = Person()
// добавляем в него резиденцию
//man.residence = residence
// получаем доступ к комнатам с помощью опциональной цепочки
//if let rooms = man.residence?.rooms {
// // действия с коллекцией типа [Room]
//}


//С помощью опциональной цепочки происходит последовательный доступ к каждому элементу, и в случае, если какое-то из значений отсутствует, возвращается nil.
//Таким образом, если в свойстве residence не будет значения (nil), то операция
//опционального связывания не будет выполнена, не вызвав при этом каких-либо
//ошибок.
//Вы можете использовать опциональные цепочки для вызова свойств, методов исабскриптов любого уровня вложенности. Это позволяет «пробираться» через свойства
//внутри сложных моделей вложенных типов и проверять возможность доступа к их
//элементам. Например, вы могли бы осуществить доступ следующим образом:
//man.residence?.kitchen?.table?.move()
//И если значение отсутствует хотя бы в одном элементе, то результатом выражения
//будет nil.


//29.2. Установка значений через
//опциональные цепочки
//Использование опциональных цепочек не ограничивается получением доступа
//к свойствам и методам. Они также могут использоваться для инициализации
//значений.
//29.4. Доступ к сабскриптам через опциональные цепочки   403
//В листинге 29.7 показан пример того, как с помощью опциональной цепочки
//можно передать значение.
//Листинг 29.7
//let room1 = Room(square: 15)
//let room2 = Room(square: 25)
//man.residence?.rooms = [room1, room2]
//Если при доступе к rooms значение свойства residence будет nil, программа не
//вызовет ошибку, а только не выполнит операцию инициализации.


//29.3. Доступ к методам через
//опциональные цепочки
//Опциональные цепочки могут быть использованы не только для доступа к свойствам, но и для вызова методов. В класс Residence добавим новый метод, который
//должен обеспечивать вывод информации о количестве комнат (листинг 29.8).
//Листинг 29.8
//class Residence {
// var rooms:[Room]?
// func roomsCount() -> Int {
// if let rooms = self.rooms {
// return rooms.count
// } else {
// return 1
// }
// }
//}
//Для вызова данного метода также можно воспользоваться опциональной последовательностью (листинг 29.9).
//Листинг 29.9
//man.residence?.roomsCount() // 2



//29.4. Доступ к сабскриптам через
//опциональные цепочки
//Опциональные цепочки также могут быть использованы и для доступа к сабскриптам. В листинге 29.10 показан пример доступа к первому элементу коллекции типа [Room]?. При этом если в коллекции отсутствует значение, выражение
//вернет nil.
//404   Глава 29. Опциональные цепочки
//Листинг 29.10
//let firstRoom = man.residence?.rooms?[0]
//type(of:firstRoom) // Room?
//Такой способ доступа можно использовать и для инициализации значений (листинг 29.11).
//Листинг 29.11
//man.residence?.rooms?[0] = Room(square: 35)
//man.residence?.rooms?[0].square // 35
