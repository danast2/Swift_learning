//
//  extensions.swift
//  Swift_learning
//
//  Created by Даниил Асташов on 25.10.2024.
//

import Foundation


//Расширения (extension) позволяют добавить новую функциональность к уже
//существующему объектному типу (классу, структуре, перечислению) или протоколу. Таким образом вы можете расширять возможности любых типов, даже тех,
//что входят в состав Swift, то есть таких типов данных, доступ к исходным кодам
//которых у вас отсутствует. Расширения — это прекрасный и очень полезный
//функциональный элемент языка!
//С помощью расширений вы можете:
// добавить вычисляемые свойства экземпляра и вычисляемые свойства типа
//(static) к объектному типу;
// добавить методы экземпляра и методы типа к объектному типу;
// добавить новые инициализаторы, сабскрипты и вложенные типы;
// подписать тип данных на протокол и обеспечить выполнение его требований.
//Расширения могут добавлять новую функциональность к типу, но не могут изменять существующую. Суть расширения состоит исключительно в наращивании
//возможностей, но не в их изменении.


//extension ИмяРасширяемогоТипа {
// // описание новой функциональности для расширяемого типа
//}
//Для объявления расширения используется ключевое слово extension, после которого
//указывается имя расширяемого типа данных. Именно к указанному типу применяются все
//описанные в теле расширения возможности.
//Новая функциональность, добавляемая расширением, становится доступной
//всем экземплярам расширяемого объектного типа вне зависимости от того, где
//эти экземпляры объявлены.
//31.1. Вычисляемые свойства в расширениях
//Расширения могут добавлять вычисляемые свойства экземпляра и вычисляемые
//свойства типа в уже существующий объектный тип.


//Расширения могут добавлять только новые вычисляемые свойства. При попытке добавить хранимые свойства или наблюдателей свойств происходит ошибка.
//Рассмотрим следующий пример. Ваша программа оперирует расстояниями и использует для этого значения типа Double. По умолчанию такое значение определяет
//расстояние в метрах, но вам требуется организовать оперативный перевод метров
//в другие единицы измерения расстояний. Для этого расширим тип данных Double
//и добавим в него несколько специальных вычисляемых свойств (листинг 31.1).
//Листинг 31.1
extension Double {
 var asKM: Double { return self / 1000.0 }
 var asM: Double { return self }
 var asCM: Double { return self * 100.0 }
 var asMM: Double { return self * 1000.0 }
}
//Теперь при необходимости перевести расстояние из метров в другие единицы мы
//просто воспользуемся одним из свойств (листинг 31.2).
//Листинг 31.2
let length: Double = 25 // 25 метров
//length.asKM // расстояние 25 метров в километрах - 0.025
//length.asMM // расстояние 25 метров в миллиметрах — 25000
//Применение геттеров и сеттеров для вычисляемых свойств позволит использовать
//их возможности по максимуму (листинг 31.3).


extension Double {
     var asFT: Double {
         get {
             return self / 0.3048
         }
         set(newValue) {
             self = newValue * 0.3048
         }
     }
}
var distance: Double = 100 // расстояние 100 метров
//distance.asFT // расстояние 100 метров в футах - 328.08 фута
//// установим расстояние в футах, но оно будет сохранено в метрах
//distance.asFT = 150 // 45.72 метра


//31.2. Методы в расширениях
//Расширения могут добавлять в объектные типы не только свойства, но и методы.
//Рассмотрим пример из листинга 31.4, в котором расширяется тип Int. В нем
//31.3. Инициализаторы в расширениях   417
//появился новый метод repetitions, принимающий на входе замыкание типа
//() -> (). Данный метод предназначен для того, чтобы выполнять переданное
//замыкание столько раз, сколько указывает собственное значение целого числа.
//Листинг 31.4


/*extension Int {
 func repetitions(task: () -> ()) {
 for _ in 0..<self {
 task()
 }
 }
}
3.repetitions {
 print("Swift")
}*/

//Консоль
//Swift
//Swift
//Swift
//Для изменения свойств перечислений (enum) и структур (struct) не забывайте
//использовать модификатор mutating. В листинге 31.5 в расширении объявляется
//метод square(), который возводит в квадрат собственное значение экземпляра.
//Так как тип Int является структурой, то для изменения собственного значения
//экземпляра необходимо использовать ключевое слово mutating.


//31.3. Инициализаторы в расширениях
//Благодаря расширениям появляется возможность добавлять новые инициализаторы к существующему объектному типу. Так, вы можете расширить типы, например, для обработки экземпляров ваших собственных типов в качестве входных
//аргументов.
//ПРИМЕЧАНИЕ Для классов расширения могут добавлять только новые вспомогательные
//инициализаторы. Попытка добавить назначенный инициализатор или деинициализатор приведет к ошибке.
//В качестве примера создадим структуру Line, описывающую линию на плоскости.
//С помощью расширения реализуем инициализатор типа Double, принимающий на
//418   Глава 31. Расширения
//вход экземпляр данной структуры и устанавливающий значение, соответствующее
//длине линии (листинг 31.6).


import Foundation
struct Line {
     var pointOne: (Double, Double)
     var pointTwo: (Double, Double)
}
extension Double {
 init(line: Line) {
     self = sqrt(
     pow((line.pointTwo.0 - line.pointOne.0), 2) +
     pow((line.pointTwo.1 - line.pointOne.1), 2))
 }
}
var myLine = Line(pointOne: (10,10), pointTwo: (14,10))
var lineLength = Double(line: myLine) // 4


//Импортированная в первой строке листинга библиотека Foundation обеспечивает
//доступ к математическим функциям sqrt(_:) и pow(_:_:) (вычисление квадратного корня и возведение в степень), которые требуются для вычисления длины
//линии на плоскости.
//Структура Line описывает сущность «линия», в свойствах которой указываются
//координаты точек ее начала и конца. Созданный в расширении инициализатор
//принимает на входе экземпляр класса Line и на основе значений его свойств вычисляет требуемое значение.
//При разработке нового инициализатора в расширении будьте крайне внимательны, чтобы к завершению инициализации каждое из свойств расширяемого типа
//имело определенное значение. Например, если вы напишете расширение уже для
//типа Line, но в нем проинициализуете значение только для одного из свойств этого
//типа, это приведет к ошибке.


//31.4. Сабскрипты в расширениях
//Помимо свойств, методов и инициализаторов, расширения позволяют создавать
//новые сабскрипты.
//Создаваемое в листинге 31.7 расширение типа Int реализует новый сабскрипт,
//который позволяет получить определенную цифру собственного значения экземпляра. В сабскрипте указывается номер позиции цифры, которую необходимо
//вернуть.


extension Int {
 subscript( digitIndex: Int ) -> Int {
     var base = 1
     var index = digitIndex
     while index > 0 {
         base *= 10
         index -= 1
     }
         return (self / base) % 10
 }
}
//746381295[0] // 5
//746381295[1] // 9
//Если у числа отсутствует цифра с запрошенным индексом, возвращается 0, что
//не нарушает логику работы.


//31.5. Расширения протоколов
//Как вы знаете, расширения могут применяться к любым объектным типам. В этом
//разделе я бы хотел отдельно рассмотреть возможности совместного использования
//расширений и протоколов.
//Подпись объектного типа на протокол
//С помощью расширений у вас есть возможность подписать существующий тип
//на определенный протокол. Для этого в расширении после имени типа данных
//через двоеточие необходимо указать список новых протоколов. В листинге 31.8
//тип данных Int подписывается на протокол TextRepresentable, который требует
//наличия метода asText().


protocol TextRepresentable {
 func asText() -> String
}
extension Int: TextRepresentable {
 func asText() -> String {
 return String(self)
 }
}
//
//5.asText() // "5"


//С помощью расширения мы добавляем требование о соответствии типа протоколу,
//при этом обязательно указывается реализация метода.
//420   Глава 31. Расширения
//Расширение протоколов и реализации по умолчанию
//Расширения могут расширять не только конкретные типы данных, но и протоколы.
//При этом они позволяют указать реализацию по умолчанию для любого метода
//этого протокола (листинг 31.9).


protocol Descriptional {
 func getDescription() -> String
}
// расширение протокола и указание реализации метода по умолчанию
extension Descriptional {
 func getDescription() -> String {
 return "Описание объектного типа"
 }
}
// подпишем класс на протокол
class myClass: Descriptional {}
// вызовем метод
//print(myClass().getDescription())


//Консоль
//Описание объектного типа
//Несмотря на то что в классе myClass отсутствует реализация метода getDescription(), при его вызове не появляются сообщения об ошибках. Это связано с тем,
//что протокол имеет реализацию метода по умолчанию, описанную в его расширении.
//ПРИМЕЧАНИЕ Реализация методов по умолчанию для протоколов доступна только при
//использовании расширений. Вы не можете наполнить метод непосредственно при объявлении
//протокола.
//При этом вы всегда можете переопределить реализацию по умолчанию непосредственно в самом объектном типе (листинг 31.10).


class myStruct: Descriptional {
 func getDescription() -> String {
     return "Описание структуры"
 }
}
//myStruct().getDescription() // "Описание структуры"


//ПРИМЕЧАНИЕ Реализация методов по умолчанию, а также множественное наследование
//протоколов являются основой методологии протокол-ориентированного программирования,
//о котором уже упоминалось ранее в книге.
//31.5. Расширения протоколов   421
//С помощью расширений вы можете в том числе расширять и сами протоколы.
//При объявлении расширения необходимо использовать имя протокола, а в его теле
//указывать набор требований с их реализациями. После расширения протокола
//описанные в нем реализации становятся доступны в экземплярах всех классов,
//которые приняли данный протокол к реализации.
//Напишем расширение для реализованного ранее протокола TextRepresentable
//(листинг 31.11).


extension TextRepresentable {
 func about() -> String {
     return "Данный тип поддерживает протокол TextRepresentable"
 }
}


//Расширение добавляет новый метод в протокол TextRepresentable. При этом ранее
//мы указали, что тип Int соответствует данному протоколу. В связи с этим появляется возможность обратиться к указанному методу для любого значения типа Int.
//Знание и правильное использование протоколов — очень важный навык, так как
//Swift является первым протокол-ориентированным языком программирования.
//В следующей главе мы поговорим о преимуществах, которые приносит использование протоколов
