//
//  extensions.swift
//  Swift_learning
//
//  Created by Даниил Асташов on 25.10.2024.
//

import Foundation


//Расширения (extension) позволяют добавить новую функциональность к уже
//существующему объектному типу (классу, структуре, перечислению) или протоколу. Таким образом вы можете расширять возможности любых типов, даже тех,
//что входят в состав Swift, то есть таких типов данных, доступ к исходным кодам
//которых у вас отсутствует. Расширения — это прекрасный и очень полезный
//функциональный элемент языка!
//С помощью расширений вы можете:
// добавить вычисляемые свойства экземпляра и вычисляемые свойства типа
//(static) к объектному типу;
// добавить методы экземпляра и методы типа к объектному типу;
// добавить новые инициализаторы, сабскрипты и вложенные типы;
// подписать тип данных на протокол и обеспечить выполнение его требований.
//Расширения могут добавлять новую функциональность к типу, но не могут изменять существующую. Суть расширения состоит исключительно в наращивании
//возможностей, но не в их изменении.


//extension ИмяРасширяемогоТипа {
// // описание новой функциональности для расширяемого типа
//}
//Для объявления расширения используется ключевое слово extension, после которого
//указывается имя расширяемого типа данных. Именно к указанному типу применяются все
//описанные в теле расширения возможности.
//Новая функциональность, добавляемая расширением, становится доступной
//всем экземплярам расширяемого объектного типа вне зависимости от того, где
//эти экземпляры объявлены.
//31.1. Вычисляемые свойства в расширениях
//Расширения могут добавлять вычисляемые свойства экземпляра и вычисляемые
//свойства типа в уже существующий объектный тип.


//Расширения могут добавлять только новые вычисляемые свойства. При попытке добавить хранимые свойства или наблюдателей свойств происходит ошибка.
//Рассмотрим следующий пример. Ваша программа оперирует расстояниями и использует для этого значения типа Double. По умолчанию такое значение определяет
//расстояние в метрах, но вам требуется организовать оперативный перевод метров
//в другие единицы измерения расстояний. Для этого расширим тип данных Double
//и добавим в него несколько специальных вычисляемых свойств (листинг 31.1).
//Листинг 31.1
extension Double {
 var asKM: Double { return self / 1000.0 }
 var asM: Double { return self }
 var asCM: Double { return self * 100.0 }
 var asMM: Double { return self * 1000.0 }
}
//Теперь при необходимости перевести расстояние из метров в другие единицы мы
//просто воспользуемся одним из свойств (листинг 31.2).
//Листинг 31.2
let length: Double = 25 // 25 метров
//length.asKM // расстояние 25 метров в километрах - 0.025
//length.asMM // расстояние 25 метров в миллиметрах — 25000
//Применение геттеров и сеттеров для вычисляемых свойств позволит использовать
//их возможности по максимуму (листинг 31.3).


extension Double {
     var asFT: Double {
         get {
             return self / 0.3048
         }
         set(newValue) {
             self = newValue * 0.3048
         }
     }
}
var distance: Double = 100 // расстояние 100 метров
//distance.asFT // расстояние 100 метров в футах - 328.08 фута
//// установим расстояние в футах, но оно будет сохранено в метрах
//distance.asFT = 150 // 45.72 метра


//31.2. Методы в расширениях
//Расширения могут добавлять в объектные типы не только свойства, но и методы.
//Рассмотрим пример из листинга 31.4, в котором расширяется тип Int. В нем
//31.3. Инициализаторы в расширениях   417
//появился новый метод repetitions, принимающий на входе замыкание типа
//() -> (). Данный метод предназначен для того, чтобы выполнять переданное
//замыкание столько раз, сколько указывает собственное значение целого числа.
//Листинг 31.4


/*extension Int {
 func repetitions(task: () -> ()) {
 for _ in 0..<self {
 task()
 }
 }
}
3.repetitions {
 print("Swift")
}*/

//Консоль
//Swift
//Swift
//Swift
//Для изменения свойств перечислений (enum) и структур (struct) не забывайте
//использовать модификатор mutating. В листинге 31.5 в расширении объявляется
//метод square(), который возводит в квадрат собственное значение экземпляра.
//Так как тип Int является структурой, то для изменения собственного значения
//экземпляра необходимо использовать ключевое слово mutating.


//31.3. Инициализаторы в расширениях
//Благодаря расширениям появляется возможность добавлять новые инициализаторы к существующему объектному типу. Так, вы можете расширить типы, например, для обработки экземпляров ваших собственных типов в качестве входных
//аргументов.
//ПРИМЕЧАНИЕ Для классов расширения могут добавлять только новые вспомогательные
//инициализаторы. Попытка добавить назначенный инициализатор или деинициализатор приведет к ошибке.
//В качестве примера создадим структуру Line, описывающую линию на плоскости.
//С помощью расширения реализуем инициализатор типа Double, принимающий на
//418   Глава 31. Расширения
//вход экземпляр данной структуры и устанавливающий значение, соответствующее
//длине линии (листинг 31.6).


import Foundation
struct Line {
     var pointOne: (Double, Double)
     var pointTwo: (Double, Double)
}
extension Double {
 init(line: Line) {
     self = sqrt(
     pow((line.pointTwo.0 - line.pointOne.0), 2) +
     pow((line.pointTwo.1 - line.pointOne.1), 2))
 }
}
var myLine = Line(pointOne: (10,10), pointTwo: (14,10))
var lineLength = Double(line: myLine) // 4


//Импортированная в первой строке листинга библиотека Foundation обеспечивает
//доступ к математическим функциям sqrt(_:) и pow(_:_:) (вычисление квадратного корня и возведение в степень), которые требуются для вычисления длины
//линии на плоскости.
//Структура Line описывает сущность «линия», в свойствах которой указываются
//координаты точек ее начала и конца. Созданный в расширении инициализатор
//принимает на входе экземпляр класса Line и на основе значений его свойств вычисляет требуемое значение.
//При разработке нового инициализатора в расширении будьте крайне внимательны, чтобы к завершению инициализации каждое из свойств расширяемого типа
//имело определенное значение. Например, если вы напишете расширение уже для
//типа Line, но в нем проинициализуете значение только для одного из свойств этого
//типа, это приведет к ошибке.


//31.4. Сабскрипты в расширениях
//Помимо свойств, методов и инициализаторов, расширения позволяют создавать
//новые сабскрипты.
//Создаваемое в листинге 31.7 расширение типа Int реализует новый сабскрипт,
//который позволяет получить определенную цифру собственного значения экземпляра. В сабскрипте указывается номер позиции цифры, которую необходимо
//вернуть.


extension Int {
 subscript( digitIndex: Int ) -> Int {
     var base = 1
     var index = digitIndex
     while index > 0 {
         base *= 10
         index -= 1
     }
         return (self / base) % 10
 }
}
//746381295[0] // 5
//746381295[1] // 9
//Если у числа отсутствует цифра с запрошенным индексом, возвращается 0, что
//не нарушает логику работы.
