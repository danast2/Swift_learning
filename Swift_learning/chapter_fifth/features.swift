//
//  features.swift
//  Swift_learning
//
//  Created by Даниил Асташов on 23.10.2024.
//

import Foundation


//Свойства — неотъемлемая часть объектных типов. В этой главе мы более подробно
//разберем их возможности.
//22.1. Типы свойств
//Свойства — это параметры, объявленные в пределах объектного типа данных. Они
//позволяют хранить или вычислять значения.
//По типу значения можно выделить два основных вида свойств:
// хранимые свойства могут использоваться в структурах и классах;
// вычисляемые свойства могут использоваться в перечислениях, структурах
//и классах.
//Хранимые свойства
//Хранимое свойство — это константа или переменная, объявленная в объектном
//типе и хранящая определенное значение. Хранимое свойство может:
// получить значение в инициализаторе (метод с именем init);
// получить значение по умолчанию в случае, если при создании экземпляра ему
//не передается никакое значение;
// изменить значение в процессе использования экземпляра.
//Мы уже многократно создавали хранимые свойства ранее, например, при реализации класса Chessman.
//Ленивые хранимые свойства
//Хранимые свойства могут быть «ленивыми». Значение, которое должно храниться
//в ленивом свойстве, не создается до момента первого обращения к нему.


//Рассмотрим пример. Создадим класс, описывающий человека. В нем будут свойства, содержащие информацию об имени и фамилии. Также будет определен
//метод, возвращающий полное имя (имя и фамилию вместе), и ленивое свойство,
//содержащее значение данного метода (листинг 22.1).


class Person {
 var firstName = "Имя"
 var secondName = "Фамилия"
 lazy var wholeName: String = self.generateWholeName()
 init(name: String, secondName: String) {
     ( self.firstName, self.secondName ) = ( name, secondName )
 }
 func generateWholeName() -> String {
     return firstName + " " + secondName
 }
}
var me = Person(name:"Егор", secondName:"Петров")
//me.wholeName


//Экземпляр класса Person упрощенно описывает сущность «человек». В свойстве
//wholeName должно храниться его полное имя, но при создании экземпляра его
//значение не задается. При этом оно не равно nil, оно просто не сгенерировано и не
//записано. Это связано с тем, что свойство является ленивым. Как только происходит обращение к данному свойству, его значение формируется.
//Ленивые свойства позволяют экономить оперативную память и не расходовать
//ее до тех пор, пока не потребуется значение какого-либо свойства.
//ПРИМЕЧАНИЕ Стоит отметить, что в качестве значений для хранимых свойств нельзя
//указывать элементы (свойства и методы) того же объектного типа. Ленивые свойства не имеют
//этого ограничения, так как их значения формируются уже после создания экземпляров.
//Ленивые свойства являются lazy-by-need, то есть вычисляются однажды и больше
//не меняют свое значение. Это продемонстрировано в листинге 22.2.


//Несмотря на то что значение свойства secondName было изменено, значение ленивого свойства wholeName осталось прежним.
//Методы типов данных в некоторой степени тоже являются ленивыми: они вычисляют значение при обращении к ним, но делают это каждый раз. Если внимательно посмотреть на структуру класса Person, то для получения полного имени
//можно было обращаться к методу generateWholeName() вместо ленивого свойства wholeName. Но также можно было пойти и другим путем: создать ленивое хранимое
//свойство функционального типа, содержащее в себе замыкание (листинг 22.3).


class Person_new {
 var firstName = "Имя"
 var secondName = "Фамилия"
 lazy var wholeName: ()->String = { "\(self.firstName) \(self.secondName)" }
 init(name: String, secondName: String) {
     ( self.firstName, self.secondName ) = ( name, secondName )
 }
}


var otherMan = Person(name: "Алексей", secondName:"Олейник")
//otherMan.wholeName() // "Алексей Олейник"
//otherMan.secondName = "Дуров"
//otherMan.wholeName() // "Алексей Дуров"


//Обратите внимание, что так как свойство хранит в себе замыкание, доступ к нему
//необходимо организовать с использованием скобок.
//При этом свойство wholeName, хранящее в себе замыкание, будет возвращать
//актуальное значение каждый раз при обращении к нему. То есть данное ленивое
//хранимое свойство называется lazy-by-name.
//Почему необходимо использовать lazy для свойства wholeName? Обратите внимание, что при получении значения свойства wholeName происходит обращение
//к элементам этого же объектного типа (с помощью ключевого слова self). Такой
//подход доступен только для ленивых хранимых свойств: если убрать lazy, то
//Xcode сообщит об ошибке:
//error: Cannot find 'self' in scope
//В данном случае использование self является обязательным, так как происходит
//захват ссылки на объект (при необходимости об этом вам сообщит сам Xcode).
//Более подробно о захвате ссылок на объекты мы поговорим в главе, посвященной
//управлению памятью в Swift


//вычисляемые свойства

//Также существует иной способ создать параметр, значение которого будет вычисляться при каждом доступе к нему. Для этого можно использовать уже знакомые
//нам по перечислениям вычисляемые свойства. По сути, это те же ленивые хранимые свойства, имеющие функциональный тип, но определяемые в упрощенном
//синтаксисе.
//Вычисляемые свойства фактически не хранят значение, а вычисляют его с помощью замыкающего выражения при каждом обращении к ним.
//346   Глава 22. Свойства
//СИНТАКСИС
//var имяСвойства: ТипДанных { тело_замыкающего_выражения }
//Вычисляемые свойства могут храниться исключительно в переменных (var). После указания
//имени объявляемого свойства и типа возвращаемого замыкающим выражением значения
//без оператора присваивания указывается замыкание, в результате которого должно быть
//сгенерировано возвращаемое свойством значение.
//Для того чтобы свойство возвращало некоторое значение, в теле замыкания должен присутствовать оператор return.
//Сделаем свойство wholeName класса Person вычисляемым (листинг 22.4).


class Person_m {
 var firstName = "Имя"
 var secondName = "Фамилия"
 var wholeName: String { return "\(self.firstName) \(self.secondName)" }
 init(name: String, secondName: String) {
     ( self.firstName, self.secondName ) = ( name, secondName )
 }
}
var otherMan_m = Person_m(name: "Алексей", secondName:"Олейник")
//otherMan.wholeName // "Алексей Олейник"
//otherMan.secondName = "Дуров"
//otherMan.wholeName // "Алексей Дуров"


//контроль значений свойств

//Для любого вычисляемого свойства существует возможность реализовать две
//специальные функции:
// Геттер (get) выполняет некоторый код при попытке получить значение вычисляемого свойства.
// Сеттер (set) выполняет некоторый код при попытке установить значение
//вычисляемому свойству.
//Во всех объявленных ранее вычисляемых свойствах был реализован только геттер,
//поэтому они являлись свойствами «только для чтения», то есть попытка изменения
//вызвала бы ошибку. При этом не требовалось писать какой-либо код, который бы
//указывал на то, что существует некий геттер.
//22.2. Контроль значений свойств   347
//В случае, если вычисляемое свойство должно иметь и геттер и сеттер, необходимо
//использовать специальный синтаксис.
