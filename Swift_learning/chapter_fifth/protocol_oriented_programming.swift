//
//  protocol_oriented_programming.swift
//  Swift_learning
//
//  Created by Даниил Асташов on 25.10.2024.
//

import Foundation


//Глава 32. Протоколориентированное
//программирование
//В этой главе я бы хотел поговорить о методологии разработки приложений
//«Протокол-ориентированное программирование» (ПОП), а также рассмотреть
//несколько сопутствующих вопросов. Глава станет для вас введением в ПОП. По
//мере того как вы будете накапливать опыт разработки, вы сможете самостоятельно
//вернуться к темам, рассмотренным в данной главе, и взглянуть на них уже под
//другим углом.
//32.1. Важность использования протоколов
//Протокол (или интерфейс) — это понятие, которое относится не только к области программирования. Вы могли встречать протоколы (интерфейсы) повсюду,
//начиная от работы в Сети (сетевые протоколы — HTTP, FTP, SSL и т. д.) до повседневной жизни. Так, например, электрическая розетка — это также определенный интерфейс, с которым у вас есть возможность взаимодействовать только
//определенным образом (вставить вилку в розетку). И если в вилке расстояние
//между контактами будет больше или количество контактов будет другое, то
//взаимодействия не произойдет. Таких примеров множество: пульт от телевизора,
//духовка, кухонный нож — каждый из них имеет свой интерфейс, или стандарт,
//через который вы взаимодействуете с данным объектом. И стоит отойти от правил,
//требуемый результат не будет достигнут. Другой пример: вы нажимаете на кнопку
//включения PS5, и вам неважно, как именно эта команда будет отработана, важен
//лишь результат — консоль перешла в активный режим.
//Интерфейс — это стандарт, описывающий порядок взаимодействия с объектом.
//Иными словами, это набор требований, которым должен удовлетворять объект,
//чтобы с ним можно было производить взаимодействие установленным образом.
//ПРИМЕЧАНИЕ Зачастую хакеры занимаются поиском уязвимостей в протоколах, то есть
//стараются найти способы взаимодействия, не предусмотренные стандартом. Так, если вместо
//вилки вы вставите в розетку пальцы, то в некотором роде можете почувствовать себя хакером,
//так как используете интерфейс не по назначению.


//На всякий случай уточню: это была шутка, не стоит искать уязвимости подобного рода, особенно
//в физических интерфейсах.
//Протокол (protocol) в Swift подобен интерфейсу в реальной жизни: с его помощью вы можете определить, какие элементы доступны вам при взаимодействии
//с тем или иным объектом, не вдаваясь в конкретную реализацию. К примеру, вы
//работаете с объектом типа Car, подписанным на протокол Drive, в котором есть
//требования реализации метода driveForward(withSpeed:), а значит, данный метод
//доступен и в самом объекте.
//Есть три важнейшие причины использования протоколов. В протоколах обеспечивается:
//1) целостность типов данных;
//2) инкапсуляция;
//3) полиморфизм.
//Целостность типов данных
//Использование протоколов обеспечивает целостность типов данных. Другими
//словами, если некоторый объектный тип подписан на протокол, то с уверенностью
//можно утверждать, что в нем реализованы требования данного протокола.
//Сам по себе тип не обязан иметь какую-либо функциональность, но протокол,
//в свою очередь, обязывает его. И если в протоколе есть требование реализовать
//конкретное свойство или метод, то оно однозначно будет доступно при работе
//с типом. Например, если тип реализует требования протокола Hashable, то вы
//сможете получить конкретное уникальное целочисленное значение при доступе
//к свойству hashValue, так как в протоколе есть соответствующее требование.
//Инкапсуляция
//Инкапсуляция — это подход, при котором данные и методы для работы с этими
//данными объединяются в единую сущность, при этом скрывая свою внутреннюю
//реализацию.
//Рассмотрим пример. Сущность «Телевизор» в реальном мире объединяет данные
//(телевизионных программ) и методы (переключение программ, изменение громкости и т. д.). При этом вы совсем ничего не знаете, как все это функционирует,
//вы лишь используете интерфейс телевизора (нажимаете кнопки на пульте) и получаете результат. Таким образом, можно сказать, что в данном объекте инкапсулируются данные и методы.
//В листинге 32.1 приведен пример того, как бы мог выглядеть телевизор в виде
//программного кода.


// сущность ТВ-шоу
class TVShow {
 // ...
}
// протокол, описывающий функциональность работы с ТВ-шоу
protocol DisplayShow {
 func getShowsList() -> [TVShow]
 func changeShowTo(show: TVShow) -> Void
 var currentShow: TVShow { get }
 // дополнительные требования ...
}
// протокол, описывающий функциональность управления звуком
protocol ChangeVolume {
 var currentVolume: UInt8 { get set }
 func increase(by: UInt8) -> Void
 func decrease(by: UInt8) -> Void
 // дополнительные требования...
}
// сущность Телевизор принимает протоколы к исполнению
//struct TV: DisplayShow, ChangeVolume {
// // реализация методов и свойств протоколов ...
//}


//Если бы структура TV не принимала протокол ChangeVolume, то у нас не было бы
//гарантии, что она реализует управление громкостью. Если бы структура TV не
//принимала протокол DisplayShow, то у нас не было бы гарантии, что она реализует
//показ телевизионных передач.
//Таким образом, если всегда начинать разработку класса или структуры с протоколов, то сначала вы определяетесь с тем, что должны делать ваши программные
//сущности, а уже потом создаете их реализацию.


//Полиморфизм
//Полиморфизм — это подход, предусматривающий возможность взаимодействия
//с различными типами данных единым образом в отсутствие информации о конкретном типе данных объекта.
//Например, мы могли бы разработать структуру, описывающую DVD-плеер, и так
//как данное устройство может управлять звуком, то используем при этом объявленный ранее протокол ChangeVolume (листинг 32.2).


//struct DVDPlayer: ChangeVolume {
// // реализация методов и свойств протоколов ...
//}
//32.2. Протокол-ориентированное программирование   425
//Теперь предположим, что мы разработали универсальный пульт, который может
//менять громкость любого устройства, имеющего интерфейс управления звуком
//(соответствует протоколу ChangeVolume) (листинг 32.3).
//Листинг 32.3
struct UniversalManager {
 var currentDevice: ChangeVolume
 func increaseVolume(by: UInt8) -> Void {
 self.currentDevice.increase(by: by)
 }
 // ...
}
// начнем работу с DVD-плеером
//let manager = UniversalManager(currentDevice: DVDPlayer())
//manager.increaseVolume(by: 1)
//// переключимся на работу с телевизором
//manager.currentDevice = TV()
//manager.increaseVolume(by: 5)


//Таким образом, вы можете настроить значение типа UniversalManager хоть на
//работу с TV, хоть на работу с DVDPlayer. В этом и есть суть полиморфизма. Наш
//универсальный пульт может взаимодействовать с любым объектом, не имея информации о его конкретном типе.
//Конечно, можно добиться подобного результата и без протоколов, с помощью
//наследования классов. Но Swift не поддерживает множественное наследование
//классов, зато приветствует его для протоколов.
//ПРИМЕЧАНИЕ Множественное наследование — это наследование от двух и более родите
