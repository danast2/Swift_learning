//
//  generic.swift
//  Swift_learning
//
//  Created by Даниил Асташов on 26.10.2024.
//

import Foundation


//Глава 34. Универсальные
//шаблоны (Generic)
//Функции и объектные типы (перечисления, структуры и классы) предназначены
//для того, чтобы писать хороший код, который можно многократно использовать
//и при необходимости расширять. По большому счету, вся суть этих функциональных элементов сводится к улучшению качества кода. Действительно, зачем десять
//раз повторно реализовывать загрузку требуемых значений из базы данных, когда
//можно создать функцию и при необходимости вызывать ее. Универсальные шаблоны
//(generic, или дженерик) предназначены для того, чтобы сделать ваш код еще более
//качественным: вы сможете писать меньше кода, получая тот же самый результат.


//ПРИМЕЧАНИЕ Чтобы глубоко понять и начать применять универсальные шаблоны, потребуется время. Не ограничивайтесь изучением материала этой книги, ищите новые источники знаний и уделите дженерикам пристальное внимание, так как они способны значительно
//улучшить ваш код.
//Универсальные шаблоны в Swift представлены тремя базовыми элементами:
// универсальные функции;
// универсальные протоколы;
// универсальные объектные типы.
//В этой главе мы подробно разберем каждый из них.



//34.1. Зачем нужны дженерики
//С помощью универсальных шаблонов вы сможете реализовывать очень гибкие
//конструкции без привязки к конкретным типам данных. На самом деле вы уже
//давно работаете с дженериками, вероятно, даже не подозревая об этом. К ним,
//например, относятся массивы, множества и словари, элементами которых могут
//выступать значения различных типов.
//Рассмотрим следующий пример.
//У вас есть два параметра типа Int. Перед вами стоит задача написать код, меняющий значения данных параметров между собой. Каким образом лучше решить
//эту задачу? Вероятно, написать функцию (листинг 34.1).


var first = 3
var second = 5
func change(a: inout Int, b: inout Int) {
 let tmp = first
 first = second
 second = tmp
}
//change(a: &first, b: &second)
//first // 5
//second // 3


//Для обмена значений переменных функция change(a:b:) использует сквозные
//параметры, в результате чего значения first и second меняются местами.
//Теперь перед вами встала задача реализовать обмен значениями типа String. Как
//поступить в этом случае? Ответ очевиден: написать новую функцию, которая будет
//принимать значения данного типа (листинг 34.2).


func change(a: inout String, b: inout String) {
 let tmp = first
 first = second
 second = tmp
}


//Но и этого оказалось мало. Со временем вам потребовалось бы менять местами
//значения и других типов: Double, UInt и даже некоторых собственных структур.
//Для каждого из них потребуется создать собственную функцию. Несмотря на то
//что мы применяем механизм, позволяющий избежать дублирования кода, в итоге
//мы занимаемся этим самым дублированием: функции отличаются лишь типом
//аргументов, тело всех функций идентично друг другу.
//Дженерики позволят устранить эту проблему, создав единый для всех типов
//данных механизм.


//34.2. Универсальные функции
//Наиболее удобным способом решения задачи с функцией обмена значениями
//может стать реализация универсальной функции, которая будет принимать на
//вход значения любых типов данных, после чего выполнять с ними требуемые
//операции.
//Для того чтобы объявить универсальную функцию, после имени функции в угловых скобках необходимо указать заполнитель типа, например
//change<T>
//448   Глава 34. Универсальные шаблоны (Generic)
//который будет использован в сигнатуре или в теле функции как указатель на пока
//еще не определенный тип данных. То есть с помощью заполнителя типа <T> вы
//определяете параметр типа T, который будет использоваться в качестве указателя
//на тип данных. Таким образом, в сигнатуре (и при необходимости в теле) функции
//вместо Int, String, Double и иных типов потребуется указывать T.
//Запомните:
// <T> — заполнитель типа;
// T — параметр типа.
//ПРИМЕЧАНИЕ В качестве заполнителя принято указывать символ T (первая буква в слове
//Type). При нескольких заполнителях в пределах одного дженерика используйте T1, T2 и т. д.
//Но эта рекомендация не обязывает вас использовать именно T, вы можете заменить его произвольным символом или символами.
//Реализуем универсальную функцию, меняющую значения входных параметров
//произвольных типов данных (листинг 34.3).


func change<T>(a: inout T, b: inout T) {
 let temporaryA = a
 a = b
 b = temporaryA
}

//В универсальной функции change<T>(a:b:) параметр типа T в списке аргументов
//заменяет указание на конкретный тип. Но при этом указано, что и a и b должны
//иметь один и тот же тип данных T.
//С помощью данной функции мы заменили все реализованные ранее функции
//обмена значениями. Теперь при необходимости можно использовать именно ее
//(листинг 34.4).


// используем универсальную функцию
// для строковых значений
var firstString = "one"
var secondString = "two"
//change(a: &firstString, b: &secondString)
//firstString // "two"
//secondString // "one"
// используем универсальную функцию
// для целочисленных значений
var firstInt = 3
var secondInt = 5
//change(a: &firstInt, b: & secondInt)
//firstString // 5
//secondInt // 3


//Заполнитель типа может состоять не из одного, а из нескольких параметров. В листинге 34.5 показан пример универсальной функции printValues<T1,T2>(a:b:)
//с параметрами типа T1 и T2, которые используются для указания типа данных
//аргументов. Таким образом, вы можете передать в функцию как значения различных типов (например, String и Double, Int и UInt), так и одного и того же типа.


func printValues<T1,T2>(a: T1, b: T2) {
 print("Значение 1 - \(a), значение 2 - \(b)")
}
//printValues(a: "book", b: 15)
//printValues(a: 4, b: 5)
//Консоль
//Значение 1 - book, значение 2 - 15
//Значение 1 - 4, значение 2 - 5
//Параметры типа могут быть использованы не только для аргументов, но и для возвращаемого значения. В листинге 34.6 показан пример простейшей универсальной
//функции, которая принимает значение произвольного типа данных и возвращает
//его. При этом параметр типа T используется в том числе и для указания на тип
//возвращаемого значения.


func getSelf<T>(_ a: T) -> T {
 return a
}
//getSelf(15) // 15


//Универсальные функции в значительной мере могут улучшить ваш код, позволяя
//создавать универсальные конструкции. Но это лишь вершина айсберга. В следующих разделах вы познакомитесь с универсальными типами и протоколами.


//34.3. Ограничения типа
//К параметрам типа могут быть применены различные ограничения, уточняющие,
//какие именно типы данных можно использовать в том или ином случае.
//Рассмотрим следующий пример.
//Реализуем универсальную функцию, производящую сложение переданных ей
//значений и возвращающую результат этой операции (листинг 34.7).


//func sum<T>(_ a: T, _ b: T) -> T {
// return a + b
//}


//На первый взгляд такая функция выглядит вполне рабочей, но при компиляции
//вы получите сообщение об ошибке (рис. 34.1). Дело в том, что оператор + может
//быть использован только при сложении значений конкретных типов данных
//(они перечислены в тексте ошибки). Так, например, вы вполне можете сложить
//два значения типа Int, но для типа String эта возможность недоступна. При этом
//функция sum<T> объявлена таким образом, что входные параметры могут иметь
//произвольный тип, в том числе и String (а также любой другой).


//Получается, что необходимо ввести ограничения, или, другими словами, указать,
//какие именно типы данных могут быть использованы вместо параметра T, таким
//образом исключив String (и другие неподходящие типы).
//Вполне логично будет предположить, что функция sum<T> будет использоваться
//для числовых значений, а значит, в качестве ограничения можно использовать
//протокол Numeric (на него подписаны все соответствующие типы данных). Если
//в качестве ограничения указать данный протокол, то функция сможет быть использована только для числовых значений.
//Ограничения типа могут быть указаны двумя способами:
//1. Непосредственно в заполнителе типа, через двоеточие после параметра (листинг 34.8).


func sum<T: Numeric>(_ a: T, _ b: T) -> T {
 return a + b
}
//sum(1, 6) // 7
//sum(1.1, 7.8) // 8.9
//sum("one", "two") // вызовет ошибку
//2. С помощью ключевого слова where, указываемого после сигнатуры функции
//(листинг 34.9).
//Листинг 34.9
func sum_new<T>(_ a: T, _ b: T) -> T where T: Numeric {
 return a + b
}
//sum(1, 6) // 7
//sum(1.1, 7.8) // 8.9
//sum("one", "two") // вызовет ошибку
//Любой из указанных вариантов позволит использовать функцию sum<T>(_ a: T,
//_ b: T) для сложения любых числовых значений.
//Рассмотрим еще один пример использования ограничения типа. В листинге 34.10
//реализована функция, производящая поиск переданного значения в переданном
//массиве. При этом в качестве ограничения указано, что значение должно быть
//Comparable, то есть сопоставимым (при поиске элемента массива происходит сопоставление переданного значения очередному элементу).
//ПРИМЕЧАНИЕ Как вы уже знаете, соответствие типа данных протоколу Comparable гарантирует, что значения этого типа могут быть сопоставлены друг с другом с помощью оператора ==.


func search<T: Comparable>(value: T, in collection: [T]) -> Bool {
 for item in collection {
     if item == value {
         return true
     }
 }
 return false
}
var array_m = [1,7,9,11]
//search(value: 1, in: array) // true
//search(value: 5, in: array) // false
//С помощью ограничений типа вы можете уточнять область применения дженерика.


//34.4. Универсальные объектные типы
//Помимо универсальных функций, к дженерикам относятся и универсальные
//объектные типы.
//Рассмотрим следующий пример: перед вами стоит задача реализовать механизм
//хранения целочисленных значений в виде стека. Понятие стека уже известно вам,
//мы рассматривали его в главе об управлении памятью. Такая структура данных
//характеризуется тем, что вам всегда доступен только верхний (первый) элемент
//стека. Все новые элементы добавляются в начало стека, а для доступа к нижележащим верхний элемент должен быть убран из стека.
//Для реализации стека воспользуемся структурой, реализовав в ней свойство items,
//которое будет хранить элементы стека, а также два метода:
// метод push(_:) — добавляет новый элемент в начало стека;
// метод pop() — возвращает первый элемента стека, удаляя его оттуда.
//Наличие других свойств и операций не подразумевается.
//В листинге 34.11 показана реализация структуры StackInt, способной хранить
//значения типа Int.


struct StackInt {
 var items = [Int]()
 mutating func push(_ item: Int) {
     items.insert(contentsOf: [item], at: 0)
 }
 mutating func pop() -> Int {
     return items.removeFirst()
 }
}
var intStorage = StackInt(items: [1,2,3,4,5])
//intStorage.items // [1, 2, 3, 4, 5]
//intStorage.pop() // 1
//intStorage.push(9)
//intStorage.items // [9, 2, 3, 4, 5]


//Эта структура имеет один большой недостаток: область ее применения ограничена
//типом Int. В случае необходимости работы с другими типами потребуется реализовывать новые структуры. Но и в этом случае на помощь приходят дженерики,
//а точнее, универсальные типы (листинг 34.12).


struct Stack<T> {
 var items = [T]()
     mutating func push(_ item: T) {
         items.insert(contentsOf: [item], at: 0)
     }
     mutating func pop() -> T {
         return items.removeFirst()
     }
}
var genericIntStorage = Stack(items: [1,2,3,4,5])
var genericStringStorage = Stack(items: ["Bob", "John", "Alex"])


//Для создания универсального типа вновь используется заполнитель <T>, который
//указывается после имени объектного типа. Параметр типа T обеспечивает использование любого типа данных для значений стека.
//Ограничения доступны и при работе с универсальными типами. В листинге 34.13
//показан пример стека, который может хранить только числовые значения.
//Листинг 34.13
struct Stack_n<T: Numeric> {
 var items = [T]()
 mutating func push(_ item: T) {
     items.insert(contentsOf: [item], at: 0)
 }
 mutating func pop() -> T {
     return items.removeFirst()
 }
}
//Расширения универсального типа
//Универсальные типы могут быть расширены точно так же, как и обычные объектные типы данных. В этом случае в расширении (extension) вы можете использовать параметры типа, которые были определены в самой реализации объектного
//типа. Например, если бы потребовалось расширить универсальный тип Stack,
//реализовав в нем метод, заменяющий верхний элемент на переданный, то для
//указания типа данных значения нового элемента необходимо было использовать
//T (листинг 34.14).


extension Stack {
 mutating func replaceFirst(_ newValue: T) {
 items[0] = newValue
 }
}
var genericIntStorage_m = Stack(items: [1,2,3,4,5])
//genericIntStorage.replaceFirst(10)
//genericIntStorage.items // [10, 2, 3, 4, 5]


//34.5. Универсальные протоколы
//Вернемся к примеру с универсальной функцией, производящей поиск элемента
//в переданном массиве (листинг 34.10). В качестве ограничения типа указано, что
//тип данных должен быть Comparable (сопоставимым), а конструкция [T] говорит
//о том, что вторым аргументом (значение, в котором производится поиск) может
//быть только массив (Array) или множество (Set) (литерал [T] соответствует
//только им). Но как быть, если возникла необходимость, чтобы в качестве второго
//параметра можно было передать диапазон?
//Для решения этой задачи потребуются два параметра типа вместо одного T: T1
//и T2, где T1 будет определять тип искомого элемента, а T2 — тип коллекции (листинг 34.15).
//Листинг 34.15
//func search<T1, T2>(value: T1, in collection: T2) -> Bool
// where T1: Comparable, T2: Collection {
//     for item in collection {
//         if item == value {
//             return true
//         }
//     }
// return false
//}
//Теперь дженерик использует два параметра типа (T1 и T2), для каждого из которых
//определены соответствующие ограничения:
// T1 должен быть Comparable.
// T2 должен быть Collection.
//При попытке выполнить этот код вы получите сообщение об ошибке! Но в этом
//нет ничего удивительного. Дело в том, что, введя отдельный параметр типа T2 для
//коллекции, мы потеряли связь между типом данных искомого элемента и типом
//данных элементов этой коллекции. Swift не позволяет сравнивать между собой
//значения различных типов: например, вы не можете искать String в Array<Int>.
//Но использованный синтаксис функции search не запрещает передать конфликтующие значения.
//По этой причине необходимо указать новое ограничение, которое будет говорить
//о том, что тип искомого элемента должен соответствовать типу элементов коллекции. Как это сделать? Обратимся к документации.
//h Откройте справку к протоколу Collection и найдите раздел Associated
//Types (рис. 34.2).
//Associated Types (ассоциированные, или связанные, типы) — это средство, с помощью которого протоколы могут стать универсальными. Ассоциированные типы
//содержат указания на типы данных, которые используются внутри типа, реализующего протокол. Так, например, протокол Collection описывает коллекцию
//элементов, причем заранее неизвестно, какой тип данных будут иметь эти элементы. С помощью ассоциированных типов мы можем указать некий заполнитель
//(аналогично заполнителю в универсальных функциях и универсальных типах),
//который будем использовать при описании свойств и методов внутри протокола.
//Как видно на рис. 34.2, в протоколе Collection присутствует ассоциированный
//тип Element, который содержит информацию о типе данных элемента коллекции.
//Такой ассоциированный тип может быть использован и в случае с реализованной
//нами функцией search для указания связи между T1 и T2. Для этого ограничения
//типа необходимо дополнить выражением T1 == T2.Element, то есть тип T1 должен
//быть равен типу элементов T2 (листинг 34.16).


func search2<T1, T2>(value: T1, in collection: T2) -> Bool
 where T1: Comparable, T2: Collection, T1 == T2.Element {
     for item in collection {
         if item == value {
             return true
         }
     }
 return false
}


//Теперь этот код не вызывает ошибок, а универсальная функция search может быть
//применена для поиска элемента в любой коллекции, выполняющей следующие
//требования:
// Тип данных искомого элемента соответствует протоколу Comparable.
// Поиск элемента производится в коллекции.
// Тип данных искомого элемента соответствует типу данных элементов коллекции.
//Использование ассоциированных параметров
//Протокол Collection, к которому мы только что обращались, является универсальным. И делают его таким ассоциированные типы данных. Далее мы рассмотрим, каким образом можно использовать ассоциированные типы при разработке
//собственных протоколов.
//Вернемся к разработанному ранее универсальному типу, описывающему стек
//(листинг 34.17).


struct Stack_b<T> {
 var items = [T]()
     mutating func push(_ item: T) {
         items.insert(contentsOf: [item], at: 0)
     }
     mutating func pop() -> T {
         return items.removeFirst()
     }
}


//Реализуя данную структуру, мы отошли от принципов протокол-ориентированного программирования и пропустили этап создания протокола, а ведь именно с него
//необходимо начинать реализацию любой сущности. Но как это сделать в случае
//со структурой Stack, которая является универсальной? Свойство этой структуры
//использует T, оба метода данной структуры также используют T. Как написать
//протокол, который сможет стать основной для универсального типа? Для этого
//и нужны универсальные протоколы с ассоциированными типами.
//Создавая протокол с помощью ключевых слов associatedtype, можно указать
//необходимые ассоциированные типы, после чего использовать их при описании
//требований внутри протокола.
//В листинге 34.18 показано, как будет выглядеть протокол StackProtocol, который
//станет основой для универсального типа Stack.


protocol StackProtocol {
 associatedtype ItemType
 var items: [ItemType] { get set }
 mutating func push(_: ItemType)
 mutating func pop() -> ItemType
}

//В этом протоколе с помощью ключевого слова associatedtype указывается, что
//в принимающем данный протокол объектном типе будет использован некий пока
//неизвестный тип данных, обозначенный в протоколе как ItemType.
//Таким образом, ItemType (аналогично Element в протоколе Collection) — это некий
//заполнитель, который используется, чтобы описать требования в теле протокола.
//Теперь мы можем подписать структуру Stack на данный протокол, но при этом
//в ней потребуется создать псевдоним (typealias), указывающий, что ItemType —
//это T (пока неизвестный тип) (листинг 34.19).


struct Stack_c<T>: StackProtocol {
 // псевдоним для ассоциативного типа
 typealias ItemType = T
 var items = [T]()
     mutating func push(_ item: T) {
         items.insert(contentsOf: [item], at: 0)
     }
     mutating func pop() -> T {
         return items.removeFirst()
     }
}


//В результате мы не отошли от принципов протокол-ориентированного программирования и последовательно реализовали сущность «Стек»: сперва описали
//соответствующий протокол, а уже потом основанную на нем структуру.
//Дальнейшая доработка сущности
//Но на этом мы не остановимся и в полной мере применим возможности ПОП, перенеся функциональность методов push и pop типа Stack в протокол StackProtocol
//(с помощью extension). В листинге 34.20 показан полный код, реализующий
//сущность «Стек».


protocol StackProtocol_new {
 associatedtype ItemType
 var items: [ItemType] { get set }
 mutating func push(_ item: ItemType)
 mutating func pop() -> ItemType
}
extension StackProtocol {
 mutating func push(_ item: ItemType) {
 items.insert(contentsOf: [item], at: 0)
 }

 mutating func pop() -> ItemType {
 return items.removeFirst()
 }
}
struct Stack_v<T>: StackProtocol {
 typealias ItemType = T
 var items: [T]
}
// Проверка работы
var myStack = Stack(items: [2,4,6,8])
//myStack.pop() // 2
//myStack.push(9)
//myStack.items // [9, 4, 6, 8]


//Теперь любой объектный тип, принимающий к реализации протокол StackProtocol,
//автоматически будет обладать двумя методами, обеспечивающими функционирование этой структуры данных.
//На этом мы завершаем знакомство с универсальными шаблонами и их возможностями в Swift. Настоятельно рекомендую продолжить изучение самостоятельно,
//так как полное понимание этой темы позволит вам писать качественный и очень
//компактный код, который совершенно точно оценит ваш будущий работодатель.
