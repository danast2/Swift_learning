//
//  generic.swift
//  Swift_learning
//
//  Created by Даниил Асташов on 26.10.2024.
//

import Foundation


//Глава 34. Универсальные
//шаблоны (Generic)
//Функции и объектные типы (перечисления, структуры и классы) предназначены
//для того, чтобы писать хороший код, который можно многократно использовать
//и при необходимости расширять. По большому счету, вся суть этих функциональных элементов сводится к улучшению качества кода. Действительно, зачем десять
//раз повторно реализовывать загрузку требуемых значений из базы данных, когда
//можно создать функцию и при необходимости вызывать ее. Универсальные шаблоны
//(generic, или дженерик) предназначены для того, чтобы сделать ваш код еще более
//качественным: вы сможете писать меньше кода, получая тот же самый результат.


//ПРИМЕЧАНИЕ Чтобы глубоко понять и начать применять универсальные шаблоны, потребуется время. Не ограничивайтесь изучением материала этой книги, ищите новые источники знаний и уделите дженерикам пристальное внимание, так как они способны значительно
//улучшить ваш код.
//Универсальные шаблоны в Swift представлены тремя базовыми элементами:
// универсальные функции;
// универсальные протоколы;
// универсальные объектные типы.
//В этой главе мы подробно разберем каждый из них.



//34.1. Зачем нужны дженерики
//С помощью универсальных шаблонов вы сможете реализовывать очень гибкие
//конструкции без привязки к конкретным типам данных. На самом деле вы уже
//давно работаете с дженериками, вероятно, даже не подозревая об этом. К ним,
//например, относятся массивы, множества и словари, элементами которых могут
//выступать значения различных типов.
//Рассмотрим следующий пример.
//У вас есть два параметра типа Int. Перед вами стоит задача написать код, меняющий значения данных параметров между собой. Каким образом лучше решить
//эту задачу? Вероятно, написать функцию (листинг 34.1).


var first = 3
var second = 5
func change(a: inout Int, b: inout Int) {
 let tmp = first
 first = second
 second = tmp
}
//change(a: &first, b: &second)
//first // 5
//second // 3


//Для обмена значений переменных функция change(a:b:) использует сквозные
//параметры, в результате чего значения first и second меняются местами.
//Теперь перед вами встала задача реализовать обмен значениями типа String. Как
//поступить в этом случае? Ответ очевиден: написать новую функцию, которая будет
//принимать значения данного типа (листинг 34.2).


func change(a: inout String, b: inout String) {
 let tmp = first
 first = second
 second = tmp
}


//Но и этого оказалось мало. Со временем вам потребовалось бы менять местами
//значения и других типов: Double, UInt и даже некоторых собственных структур.
//Для каждого из них потребуется создать собственную функцию. Несмотря на то
//что мы применяем механизм, позволяющий избежать дублирования кода, в итоге
//мы занимаемся этим самым дублированием: функции отличаются лишь типом
//аргументов, тело всех функций идентично друг другу.
//Дженерики позволят устранить эту проблему, создав единый для всех типов
//данных механизм.


//34.2. Универсальные функции
//Наиболее удобным способом решения задачи с функцией обмена значениями
//может стать реализация универсальной функции, которая будет принимать на
//вход значения любых типов данных, после чего выполнять с ними требуемые
//операции.
//Для того чтобы объявить универсальную функцию, после имени функции в угловых скобках необходимо указать заполнитель типа, например
//change<T>
//448   Глава 34. Универсальные шаблоны (Generic)
//который будет использован в сигнатуре или в теле функции как указатель на пока
//еще не определенный тип данных. То есть с помощью заполнителя типа <T> вы
//определяете параметр типа T, который будет использоваться в качестве указателя
//на тип данных. Таким образом, в сигнатуре (и при необходимости в теле) функции
//вместо Int, String, Double и иных типов потребуется указывать T.
//Запомните:
// <T> — заполнитель типа;
// T — параметр типа.
//ПРИМЕЧАНИЕ В качестве заполнителя принято указывать символ T (первая буква в слове
//Type). При нескольких заполнителях в пределах одного дженерика используйте T1, T2 и т. д.
//Но эта рекомендация не обязывает вас использовать именно T, вы можете заменить его произвольным символом или символами.
//Реализуем универсальную функцию, меняющую значения входных параметров
//произвольных типов данных (листинг 34.3).


func change<T>(a: inout T, b: inout T) {
 let temporaryA = a
 a = b
 b = temporaryA
}

//В универсальной функции change<T>(a:b:) параметр типа T в списке аргументов
//заменяет указание на конкретный тип. Но при этом указано, что и a и b должны
//иметь один и тот же тип данных T.
//С помощью данной функции мы заменили все реализованные ранее функции
//обмена значениями. Теперь при необходимости можно использовать именно ее
//(листинг 34.4).


// используем универсальную функцию
// для строковых значений
var firstString = "one"
var secondString = "two"
//change(a: &firstString, b: &secondString)
//firstString // "two"
//secondString // "one"
// используем универсальную функцию
// для целочисленных значений
var firstInt = 3
var secondInt = 5
//change(a: &firstInt, b: & secondInt)
//firstString // 5
//secondInt // 3


//Заполнитель типа может состоять не из одного, а из нескольких параметров. В листинге 34.5 показан пример универсальной функции printValues<T1,T2>(a:b:)
//с параметрами типа T1 и T2, которые используются для указания типа данных
//аргументов. Таким образом, вы можете передать в функцию как значения различных типов (например, String и Double, Int и UInt), так и одного и того же типа.


func printValues<T1,T2>(a: T1, b: T2) {
 print("Значение 1 - \(a), значение 2 - \(b)")
}
//printValues(a: "book", b: 15)
//printValues(a: 4, b: 5)
//Консоль
//Значение 1 - book, значение 2 - 15
//Значение 1 - 4, значение 2 - 5
//Параметры типа могут быть использованы не только для аргументов, но и для возвращаемого значения. В листинге 34.6 показан пример простейшей универсальной
//функции, которая принимает значение произвольного типа данных и возвращает
//его. При этом параметр типа T используется в том числе и для указания на тип
//возвращаемого значения.


func getSelf<T>(_ a: T) -> T {
 return a
}
//getSelf(15) // 15


//Универсальные функции в значительной мере могут улучшить ваш код, позволяя
//создавать универсальные конструкции. Но это лишь вершина айсберга. В следующих разделах вы познакомитесь с универсальными типами и протоколами.


//34.3. Ограничения типа
//К параметрам типа могут быть применены различные ограничения, уточняющие,
//какие именно типы данных можно использовать в том или ином случае.
//Рассмотрим следующий пример.
//Реализуем универсальную функцию, производящую сложение переданных ей
//значений и возвращающую результат этой операции (листинг 34.7).


//func sum<T>(_ a: T, _ b: T) -> T {
// return a + b
//}


//На первый взгляд такая функция выглядит вполне рабочей, но при компиляции
//вы получите сообщение об ошибке (рис. 34.1). Дело в том, что оператор + может
//быть использован только при сложении значений конкретных типов данных
//(они перечислены в тексте ошибки). Так, например, вы вполне можете сложить
//два значения типа Int, но для типа String эта возможность недоступна. При этом
//функция sum<T> объявлена таким образом, что входные параметры могут иметь
//произвольный тип, в том числе и String (а также любой другой).


//Получается, что необходимо ввести ограничения, или, другими словами, указать,
//какие именно типы данных могут быть использованы вместо параметра T, таким
//образом исключив String (и другие неподходящие типы).
//Вполне логично будет предположить, что функция sum<T> будет использоваться
//для числовых значений, а значит, в качестве ограничения можно использовать
//протокол Numeric (на него подписаны все соответствующие типы данных). Если
//в качестве ограничения указать данный протокол, то функция сможет быть использована только для числовых значений.
//Ограничения типа могут быть указаны двумя способами:
//1. Непосредственно в заполнителе типа, через двоеточие после параметра (листинг 34.8).


func sum<T: Numeric>(_ a: T, _ b: T) -> T {
 return a + b
}
//sum(1, 6) // 7
//sum(1.1, 7.8) // 8.9
//sum("one", "two") // вызовет ошибку
//2. С помощью ключевого слова where, указываемого после сигнатуры функции
//(листинг 34.9).
//Листинг 34.9
func sum_new<T>(_ a: T, _ b: T) -> T where T: Numeric {
 return a + b
}
//sum(1, 6) // 7
//sum(1.1, 7.8) // 8.9
//sum("one", "two") // вызовет ошибку
//Любой из указанных вариантов позволит использовать функцию sum<T>(_ a: T,
//_ b: T) для сложения любых числовых значений.
//Рассмотрим еще один пример использования ограничения типа. В листинге 34.10
//реализована функция, производящая поиск переданного значения в переданном
//массиве. При этом в качестве ограничения указано, что значение должно быть
//Comparable, то есть сопоставимым (при поиске элемента массива происходит сопоставление переданного значения очередному элементу).
//ПРИМЕЧАНИЕ Как вы уже знаете, соответствие типа данных протоколу Comparable гарантирует, что значения этого типа могут быть сопоставлены друг с другом с помощью оператора ==.


func search<T: Comparable>(value: T, in collection: [T]) -> Bool {
 for item in collection {
     if item == value {
         return true
     }
 }
 return false
}
var array_m = [1,7,9,11]
//search(value: 1, in: array) // true
//search(value: 5, in: array) // false
//С помощью ограничений типа вы можете уточнять область применения дженерика.


//34.4. Универсальные объектные типы
//Помимо универсальных функций, к дженерикам относятся и универсальные
//объектные типы.
//Рассмотрим следующий пример: перед вами стоит задача реализовать механизм
//хранения целочисленных значений в виде стека. Понятие стека уже известно вам,
//мы рассматривали его в главе об управлении памятью. Такая структура данных
//характеризуется тем, что вам всегда доступен только верхний (первый) элемент
//стека. Все новые элементы добавляются в начало стека, а для доступа к нижележащим верхний элемент должен быть убран из стека.
//Для реализации стека воспользуемся структурой, реализовав в ней свойство items,
//которое будет хранить элементы стека, а также два метода:
// метод push(_:) — добавляет новый элемент в начало стека;
// метод pop() — возвращает первый элемента стека, удаляя его оттуда.
//Наличие других свойств и операций не подразумевается.
//В листинге 34.11 показана реализация структуры StackInt, способной хранить
//значения типа Int.


struct StackInt {
 var items = [Int]()
 mutating func push(_ item: Int) {
     items.insert(contentsOf: [item], at: 0)
 }
 mutating func pop() -> Int {
     return items.removeFirst()
 }
}
var intStorage = StackInt(items: [1,2,3,4,5])
//intStorage.items // [1, 2, 3, 4, 5]
//intStorage.pop() // 1
//intStorage.push(9)
//intStorage.items // [9, 2, 3, 4, 5]


//Эта структура имеет один большой недостаток: область ее применения ограничена
//типом Int. В случае необходимости работы с другими типами потребуется реализовывать новые структуры. Но и в этом случае на помощь приходят дженерики,
//а точнее, универсальные типы (листинг 34.12).


struct Stack<T> {
 var items = [T]()
     mutating func push(_ item: T) {
         items.insert(contentsOf: [item], at: 0)
     }
     mutating func pop() -> T {
         return items.removeFirst()
     }
}
var genericIntStorage = Stack(items: [1,2,3,4,5])
var genericStringStorage = Stack(items: ["Bob", "John", "Alex"])
