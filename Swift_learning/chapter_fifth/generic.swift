//
//  generic.swift
//  Swift_learning
//
//  Created by Даниил Асташов on 26.10.2024.
//

import Foundation


//Глава 34. Универсальные
//шаблоны (Generic)
//Функции и объектные типы (перечисления, структуры и классы) предназначены
//для того, чтобы писать хороший код, который можно многократно использовать
//и при необходимости расширять. По большому счету, вся суть этих функциональных элементов сводится к улучшению качества кода. Действительно, зачем десять
//раз повторно реализовывать загрузку требуемых значений из базы данных, когда
//можно создать функцию и при необходимости вызывать ее. Универсальные шаблоны
//(generic, или дженерик) предназначены для того, чтобы сделать ваш код еще более
//качественным: вы сможете писать меньше кода, получая тот же самый результат.


//ПРИМЕЧАНИЕ Чтобы глубоко понять и начать применять универсальные шаблоны, потребуется время. Не ограничивайтесь изучением материала этой книги, ищите новые источники знаний и уделите дженерикам пристальное внимание, так как они способны значительно
//улучшить ваш код.
//Универсальные шаблоны в Swift представлены тремя базовыми элементами:
// универсальные функции;
// универсальные протоколы;
// универсальные объектные типы.
//В этой главе мы подробно разберем каждый из них.



//34.1. Зачем нужны дженерики
//С помощью универсальных шаблонов вы сможете реализовывать очень гибкие
//конструкции без привязки к конкретным типам данных. На самом деле вы уже
//давно работаете с дженериками, вероятно, даже не подозревая об этом. К ним,
//например, относятся массивы, множества и словари, элементами которых могут
//выступать значения различных типов.
//Рассмотрим следующий пример.
//У вас есть два параметра типа Int. Перед вами стоит задача написать код, меняющий значения данных параметров между собой. Каким образом лучше решить
//эту задачу? Вероятно, написать функцию (листинг 34.1).


//var first = 3
//var second = 5
//func change(a: inout Int, b: inout Int) {
// let tmp = first
// first = second
// second = tmp
//}
//change(a: &first, b: &second)
//first // 5
//second // 3


//Для обмена значений переменных функция change(a:b:) использует сквозные
//параметры, в результате чего значения first и second меняются местами.
//Теперь перед вами встала задача реализовать обмен значениями типа String. Как
//поступить в этом случае? Ответ очевиден: написать новую функцию, которая будет
//принимать значения данного типа (листинг 34.2).


//func change(a: inout String, b: inout String) {
// let tmp = first
// first = second
// second = tmp
//}


//Но и этого оказалось мало. Со временем вам потребовалось бы менять местами
//значения и других типов: Double, UInt и даже некоторых собственных структур.
//Для каждого из них потребуется создать собственную функцию. Несмотря на то
//что мы применяем механизм, позволяющий избежать дублирования кода, в итоге
//мы занимаемся этим самым дублированием: функции отличаются лишь типом
//аргументов, тело всех функций идентично друг другу.
//Дженерики позволят устранить эту проблему, создав единый для всех типов
//данных механизм.


//34.2. Универсальные функции
//Наиболее удобным способом решения задачи с функцией обмена значениями
//может стать реализация универсальной функции, которая будет принимать на
//вход значения любых типов данных, после чего выполнять с ними требуемые
//операции.
//Для того чтобы объявить универсальную функцию, после имени функции в угловых скобках необходимо указать заполнитель типа, например
//change<T>
//448   Глава 34. Универсальные шаблоны (Generic)
//который будет использован в сигнатуре или в теле функции как указатель на пока
//еще не определенный тип данных. То есть с помощью заполнителя типа <T> вы
//определяете параметр типа T, который будет использоваться в качестве указателя
//на тип данных. Таким образом, в сигнатуре (и при необходимости в теле) функции
//вместо Int, String, Double и иных типов потребуется указывать T.
//Запомните:
// <T> — заполнитель типа;
// T — параметр типа.
//ПРИМЕЧАНИЕ В качестве заполнителя принято указывать символ T (первая буква в слове
//Type). При нескольких заполнителях в пределах одного дженерика используйте T1, T2 и т. д.
//Но эта рекомендация не обязывает вас использовать именно T, вы можете заменить его произвольным символом или символами.
//Реализуем универсальную функцию, меняющую значения входных параметров
//произвольных типов данных (листинг 34.3).


func change<T>(a: inout T, b: inout T) {
 let temporaryA = a
 a = b
 b = temporaryA
}

//В универсальной функции change<T>(a:b:) параметр типа T в списке аргументов
//заменяет указание на конкретный тип. Но при этом указано, что и a и b должны
//иметь один и тот же тип данных T.
//С помощью данной функции мы заменили все реализованные ранее функции
//обмена значениями. Теперь при необходимости можно использовать именно ее
//(листинг 34.4).


// используем универсальную функцию
// для строковых значений
var firstString = "one"
var secondString = "two"
//change(a: &firstString, b: &secondString)
//firstString // "two"
//secondString // "one"
// используем универсальную функцию
// для целочисленных значений
var firstInt = 3
var secondInt = 5
//change(a: &firstInt, b: & secondInt)
//firstString // 5
//secondInt // 3


//Заполнитель типа может состоять не из одного, а из нескольких параметров. В листинге 34.5 показан пример универсальной функции printValues<T1,T2>(a:b:)
//с параметрами типа T1 и T2, которые используются для указания типа данных
//аргументов. Таким образом, вы можете передать в функцию как значения различных типов (например, String и Double, Int и UInt), так и одного и того же типа.


func printValues<T1,T2>(a: T1, b: T2) {
 print("Значение 1 - \(a), значение 2 - \(b)")
}
//printValues(a: "book", b: 15)
//printValues(a: 4, b: 5)
//Консоль
//Значение 1 - book, значение 2 - 15
//Значение 1 - 4, значение 2 - 5
//Параметры типа могут быть использованы не только для аргументов, но и для возвращаемого значения. В листинге 34.6 показан пример простейшей универсальной
//функции, которая принимает значение произвольного типа данных и возвращает
//его. При этом параметр типа T используется в том числе и для указания на тип
//возвращаемого значения.


func getSelf<T>(_ a: T) -> T {
 return a
}
//getSelf(15) // 15


//Универсальные функции в значительной мере могут улучшить ваш код, позволяя
//создавать универсальные конструкции. Но это лишь вершина айсберга. В следующих разделах вы познакомитесь с универсальными типами и протоколами.


//34.3. Ограничения типа
//К параметрам типа могут быть применены различные ограничения, уточняющие,
//какие именно типы данных можно использовать в том или ином случае.
//Рассмотрим следующий пример.
//Реализуем универсальную функцию, производящую сложение переданных ей
//значений и возвращающую результат этой операции (листинг 34.7).


//func sum<T>(_ a: T, _ b: T) -> T {
// return a + b
//}


//На первый взгляд такая функция выглядит вполне рабочей, но при компиляции
//вы получите сообщение об ошибке (рис. 34.1). Дело в том, что оператор + может
//быть использован только при сложении значений конкретных типов данных
//(они перечислены в тексте ошибки). Так, например, вы вполне можете сложить
//два значения типа Int, но для типа String эта возможность недоступна. При этом
//функция sum<T> объявлена таким образом, что входные параметры могут иметь
//произвольный тип, в том числе и String (а также любой другой).


//Получается, что необходимо ввести ограничения, или, другими словами, указать,
//какие именно типы данных могут быть использованы вместо параметра T, таким
//образом исключив String (и другие неподходящие типы).
//Вполне логично будет предположить, что функция sum<T> будет использоваться
//для числовых значений, а значит, в качестве ограничения можно использовать
//протокол Numeric (на него подписаны все соответствующие типы данных). Если
//в качестве ограничения указать данный протокол, то функция сможет быть использована только для числовых значений.
//Ограничения типа могут быть указаны двумя способами:
//1. Непосредственно в заполнителе типа, через двоеточие после параметра (листинг 34.8).


func sum<T: Numeric>(_ a: T, _ b: T) -> T {
 return a + b
}
//sum(1, 6) // 7
//sum(1.1, 7.8) // 8.9
//sum("one", "two") // вызовет ошибку
//2. С помощью ключевого слова where, указываемого после сигнатуры функции
//(листинг 34.9).
//Листинг 34.9
func sum_new<T>(_ a: T, _ b: T) -> T where T: Numeric {
 return a + b
}
//sum(1, 6) // 7
//sum(1.1, 7.8) // 8.9
//sum("one", "two") // вызовет ошибку
//Любой из указанных вариантов позволит использовать функцию sum<T>(_ a: T,
//_ b: T) для сложения любых числовых значений.
//Рассмотрим еще один пример использования ограничения типа. В листинге 34.10
//реализована функция, производящая поиск переданного значения в переданном
//массиве. При этом в качестве ограничения указано, что значение должно быть
//Comparable, то есть сопоставимым (при поиске элемента массива происходит сопоставление переданного значения очередному элементу).
//ПРИМЕЧАНИЕ Как вы уже знаете, соответствие типа данных протоколу Comparable гарантирует, что значения этого типа могут быть сопоставлены друг с другом с помощью оператора ==.


func search<T: Comparable>(value: T, in collection: [T]) -> Bool {
 for item in collection {
     if item == value {
         return true
     }
 }
 return false
}
var array_m = [1,7,9,11]
//search(value: 1, in: array) // true
//search(value: 5, in: array) // false
//С помощью ограничений типа вы можете уточнять область применения дженерика.


//34.4. Универсальные объектные типы
//Помимо универсальных функций, к дженерикам относятся и универсальные
//объектные типы.
//Рассмотрим следующий пример: перед вами стоит задача реализовать механизм
//хранения целочисленных значений в виде стека. Понятие стека уже известно вам,
//мы рассматривали его в главе об управлении памятью. Такая структура данных
//характеризуется тем, что вам всегда доступен только верхний (первый) элемент
//стека. Все новые элементы добавляются в начало стека, а для доступа к нижележащим верхний элемент должен быть убран из стека.
//Для реализации стека воспользуемся структурой, реализовав в ней свойство items,
//которое будет хранить элементы стека, а также два метода:
// метод push(_:) — добавляет новый элемент в начало стека;
// метод pop() — возвращает первый элемента стека, удаляя его оттуда.
//Наличие других свойств и операций не подразумевается.
//В листинге 34.11 показана реализация структуры StackInt, способной хранить
//значения типа Int.


struct StackInt {
 var items = [Int]()
 mutating func push(_ item: Int) {
     items.insert(contentsOf: [item], at: 0)
 }
 mutating func pop() -> Int {
     return items.removeFirst()
 }
}
var intStorage = StackInt(items: [1,2,3,4,5])
//intStorage.items // [1, 2, 3, 4, 5]
//intStorage.pop() // 1
//intStorage.push(9)
//intStorage.items // [9, 2, 3, 4, 5]


//Эта структура имеет один большой недостаток: область ее применения ограничена
//типом Int. В случае необходимости работы с другими типами потребуется реализовывать новые структуры. Но и в этом случае на помощь приходят дженерики,
//а точнее, универсальные типы (листинг 34.12).


struct Stack<T> {
 var items = [T]()
     mutating func push(_ item: T) {
         items.insert(contentsOf: [item], at: 0)
     }
     mutating func pop() -> T {
         return items.removeFirst()
     }
}
var genericIntStorage = Stack(items: [1,2,3,4,5])
var genericStringStorage = Stack(items: ["Bob", "John", "Alex"])


//Для создания универсального типа вновь используется заполнитель <T>, который
//указывается после имени объектного типа. Параметр типа T обеспечивает использование любого типа данных для значений стека.
//Ограничения доступны и при работе с универсальными типами. В листинге 34.13
//показан пример стека, который может хранить только числовые значения.
//Листинг 34.13
struct Stack_n<T: Numeric> {
 var items = [T]()
 mutating func push(_ item: T) {
     items.insert(contentsOf: [item], at: 0)
 }
 mutating func pop() -> T {
     return items.removeFirst()
 }
}
//Расширения универсального типа
//Универсальные типы могут быть расширены точно так же, как и обычные объектные типы данных. В этом случае в расширении (extension) вы можете использовать параметры типа, которые были определены в самой реализации объектного
//типа. Например, если бы потребовалось расширить универсальный тип Stack,
//реализовав в нем метод, заменяющий верхний элемент на переданный, то для
//указания типа данных значения нового элемента необходимо было использовать
//T (листинг 34.14).


extension Stack {
 mutating func replaceFirst(_ newValue: T) {
 items[0] = newValue
 }
}
var genericIntStorage_m = Stack(items: [1,2,3,4,5])
//genericIntStorage.replaceFirst(10)
//genericIntStorage.items // [10, 2, 3, 4, 5]


//34.5. Универсальные протоколы
//Вернемся к примеру с универсальной функцией, производящей поиск элемента
//в переданном массиве (листинг 34.10). В качестве ограничения типа указано, что
//тип данных должен быть Comparable (сопоставимым), а конструкция [T] говорит
//о том, что вторым аргументом (значение, в котором производится поиск) может
//быть только массив (Array) или множество (Set) (литерал [T] соответствует
//только им). Но как быть, если возникла необходимость, чтобы в качестве второго
//параметра можно было передать диапазон?
//Для решения этой задачи потребуются два параметра типа вместо одного T: T1
//и T2, где T1 будет определять тип искомого элемента, а T2 — тип коллекции (листинг 34.15).
//Листинг 34.15
//func search<T1, T2>(value: T1, in collection: T2) -> Bool
// where T1: Comparable, T2: Collection {
//     for item in collection {
//         if item == value {
//             return true
//         }
//     }
// return false
//}
//Теперь дженерик использует два параметра типа (T1 и T2), для каждого из которых
//определены соответствующие ограничения:
// T1 должен быть Comparable.
// T2 должен быть Collection.
//При попытке выполнить этот код вы получите сообщение об ошибке! Но в этом
//нет ничего удивительного. Дело в том, что, введя отдельный параметр типа T2 для
//коллекции, мы потеряли связь между типом данных искомого элемента и типом
//данных элементов этой коллекции. Swift не позволяет сравнивать между собой
//значения различных типов: например, вы не можете искать String в Array<Int>.
//Но использованный синтаксис функции search не запрещает передать конфликтующие значения.
//По этой причине необходимо указать новое ограничение, которое будет говорить
//о том, что тип искомого элемента должен соответствовать типу элементов коллекции. Как это сделать? Обратимся к документации.
//h Откройте справку к протоколу Collection и найдите раздел Associated
//Types (рис. 34.2).
//Associated Types (ассоциированные, или связанные, типы) — это средство, с помощью которого протоколы могут стать универсальными. Ассоциированные типы
//содержат указания на типы данных, которые используются внутри типа, реализующего протокол. Так, например, протокол Collection описывает коллекцию
//элементов, причем заранее неизвестно, какой тип данных будут иметь эти элементы. С помощью ассоциированных типов мы можем указать некий заполнитель
//(аналогично заполнителю в универсальных функциях и универсальных типах),
//который будем использовать при описании свойств и методов внутри протокола.
//Как видно на рис. 34.2, в протоколе Collection присутствует ассоциированный
//тип Element, который содержит информацию о типе данных элемента коллекции.
//Такой ассоциированный тип может быть использован и в случае с реализованной
//нами функцией search для указания связи между T1 и T2. Для этого ограничения
//типа необходимо дополнить выражением T1 == T2.Element, то есть тип T1 должен
//быть равен типу элементов T2 (листинг 34.16).


func search2<T1, T2>(value: T1, in collection: T2) -> Bool
 where T1: Comparable, T2: Collection, T1 == T2.Element {
     for item in collection {
         if item == value {
             return true
         }
     }
 return false
}


//Теперь этот код не вызывает ошибок, а универсальная функция search может быть
//применена для поиска элемента в любой коллекции, выполняющей следующие
//требования:
// Тип данных искомого элемента соответствует протоколу Comparable.
// Поиск элемента производится в коллекции.
// Тип данных искомого элемента соответствует типу данных элементов коллекции.
//Использование ассоциированных параметров
//Протокол Collection, к которому мы только что обращались, является универсальным. И делают его таким ассоциированные типы данных. Далее мы рассмотрим, каким образом можно использовать ассоциированные типы при разработке
//собственных протоколов.
//Вернемся к разработанному ранее универсальному типу, описывающему стек
//(листинг 34.17).


struct Stack_b<T> {
 var items = [T]()
     mutating func push(_ item: T) {
         items.insert(contentsOf: [item], at: 0)
     }
     mutating func pop() -> T {
         return items.removeFirst()
     }
}


//Реализуя данную структуру, мы отошли от принципов протокол-ориентированного программирования и пропустили этап создания протокола, а ведь именно с него
//необходимо начинать реализацию любой сущности. Но как это сделать в случае
//со структурой Stack, которая является универсальной? Свойство этой структуры
//использует T, оба метода данной структуры также используют T. Как написать
//протокол, который сможет стать основной для универсального типа? Для этого
//и нужны универсальные протоколы с ассоциированными типами.
//Создавая протокол с помощью ключевых слов associatedtype, можно указать
//необходимые ассоциированные типы, после чего использовать их при описании
//требований внутри протокола.
//В листинге 34.18 показано, как будет выглядеть протокол StackProtocol, который
//станет основой для универсального типа Stack.


protocol StackProtocol {
 associatedtype ItemType
 var items: [ItemType] { get set }
 mutating func push(_: ItemType)
 mutating func pop() -> ItemType
}

//В этом протоколе с помощью ключевого слова associatedtype указывается, что
//в принимающем данный протокол объектном типе будет использован некий пока
//неизвестный тип данных, обозначенный в протоколе как ItemType.
//Таким образом, ItemType (аналогично Element в протоколе Collection) — это некий
//заполнитель, который используется, чтобы описать требования в теле протокола.
//Теперь мы можем подписать структуру Stack на данный протокол, но при этом
//в ней потребуется создать псевдоним (typealias), указывающий, что ItemType —
//это T (пока неизвестный тип) (листинг 34.19).


struct Stack_c<T>: StackProtocol {
 // псевдоним для ассоциативного типа
 typealias ItemType = T
 var items = [T]()
     mutating func push(_ item: T) {
         items.insert(contentsOf: [item], at: 0)
     }
     mutating func pop() -> T {
         return items.removeFirst()
     }
}


//В результате мы не отошли от принципов протокол-ориентированного программирования и последовательно реализовали сущность «Стек»: сперва описали
//соответствующий протокол, а уже потом основанную на нем структуру.
//Дальнейшая доработка сущности
//Но на этом мы не остановимся и в полной мере применим возможности ПОП, перенеся функциональность методов push и pop типа Stack в протокол StackProtocol
//(с помощью extension). В листинге 34.20 показан полный код, реализующий
//сущность «Стек».


protocol StackProtocol_new {
 associatedtype ItemType
 var items: [ItemType] { get set }
 mutating func push(_ item: ItemType)
 mutating func pop() -> ItemType
}
extension StackProtocol {
 mutating func push(_ item: ItemType) {
 items.insert(contentsOf: [item], at: 0)
 }

 mutating func pop() -> ItemType {
 return items.removeFirst()
 }
}
struct Stack_v<T>: StackProtocol {
 typealias ItemType = T
 var items: [T]
}
// Проверка работы
var myStack = Stack(items: [2,4,6,8])
//myStack.pop() // 2
//myStack.push(9)
//myStack.items // [9, 4, 6, 8]


//Теперь любой объектный тип, принимающий к реализации протокол StackProtocol,
//автоматически будет обладать двумя методами, обеспечивающими функционирование этой структуры данных.
//На этом мы завершаем знакомство с универсальными шаблонами и их возможностями в Swift. Настоятельно рекомендую продолжить изучение самостоятельно,
//так как полное понимание этой темы позволит вам писать качественный и очень
//компактный код, который совершенно точно оценит ваш будущий работодатель.


//34.6. Непрозрачные типы (Opaque types)
//и ключевое слово some
//Представим, что перед нами стоит задача описать несколько типов транспортных
//средств. Решение этой задачи начнем с реализации протокола (листинг 34.21).
//Листинг 34.21
protocol Vehicle {
 var uid: Int { get set }
}
//Протокол Vehicle максимально упрощен и содержит всего одно свойство uid,
//содержащее уникальный идентификатор транспортного средства.
//Основываясь на протоколе, мы сможем реализовать необходимые структуры
//(листинг 34.22).
//Листинг 34.22
// Машина
struct Car: Vehicle {
 var uid: Int
//34.6. Непрозрачные типы (Opaque types) и ключевое слово some   459
}
// Грузовик
struct Truck: Vehicle {
 var uid: Int
}
//Теперь напишем функцию, которая возвращает экземпляр одной из структур,
//при этом тип возвращаемого значения определим, используя протокол Vehicle
//(листинг 34.23).
//Листинг 34.23
func getCar() -> Vehicle {
 return Car(uid: 93)
}
//getCar() // Car
//Давайте усложним код. Предположим, что каждый тип транспортного средства
//имеет свою систему идентификации по уникальным номерам и для свойства uid
//требуется использовать значения различных типов в различных реализациях
//протокола Vehicle. Реализуем это с помощью связанного типа (листинг 34.24).


protocol Vehicle_n {
 // связанный тип
 associatedtype Identifier
 var uid: Identifier { get set }
}
struct Car_n: Vehicle_n {
 var uid: Int
}
struct Truck_n: Vehicle_n {
 var uid: String
}
//Теперь структуры Car и Truck используют различные типы данных для свойства
//uid. Но внезапно Xcode сообщает нам об ошибке в функции getCar() (рис. 34.3).
//Рис. 34.3. Ошибка использования протокола Vehicle
//В ошибке говорится о том, что раз протокол использует ассоциированный тип
//(или ключевое слово Self), значит, он может быть использован только в качестве
//ограничения в дженерике (generic). То есть мы не можем просто взять и использовать протокол в качестве указателя на возвращаемое значения.
//460   Глава 34. Универсальные шаблоны (Generic)
//Почему так? Разберем это по шагам:
//1. Протокол Vehicle имеет связанный тип, а реализующие его структуры используют различные типы данных для свойства uid (String и Int).
//2. Для того чтобы определить возвращаемое функцией getCar() значение, компилятор не анализирует код в ее теле. В обычных условиях тип значения должен явно определяться из сигнатуры функции.
//3. В текущей реализации функция getCar() потенциально может вернуть значение любого типа данных, подписанного на протокол Vehicle. При этом заранее неизвестно, значение какого именно типа должно быть возвращено.
//4. Потенциально может произойти ситуация, при которой getCar() возвращает
//значение типа Car, когда вы ожидаете получить значение типа Truck (или наоборот). Но при этом вы будете продолжать работать со свойством uid как со
//строкой (uid в типе Truck имеет тип String), а не с целым числом (uid в типе
//Car имеет тип Int). И это приведет к ошибке Runtime


//Е Ошибка Runtime — это критическая ошибка во время выполнения программы, которая приводит к немедленной экстренной остановке работы приложения и вылету из
//него. Один из вариантов получить такую ошибку — принудительное извлечение опционального
//значения (с помощью символа !), когда в нем не содержится никакого значения (nil).
//Компилятор, основываясь на данных, которыми он обладает, не может принять
//решение о том, значение какого конкретно типа данных будет возвращено функцией getCar().
//Решение проблемы
//Как же решить эту проблему? Как использовать протокол в качестве возвращаемого значения и при этом не получить сообщение об ошибке?
//Вариант 1. Использовать дженерики.
//В тексте ошибки (см. рис. 34.3) сказано, что протокол Vehicle может быть использован в дженерике в качестве ограничения. А значит, мы можем реализовать универсальную функцию, которая возвращает значение требуемого типа (листинг 34.25)


func getCar<T: Vehicle>() -> T {
 return Car(uid: 22) as! T
}
let someVehicle: Car = getCar()

//Обратите внимание, что тип возвращаемого значения определяется явно при вызове функции (Car после имени константы). Такой подход будет вполне рабочим
//ровно до тех пор, пока вы не решите проинициализировать результат вызова
//функции getCar параметру типа Truck (изначально вы не знаете тип данных воз-
//34.6. Непрозрачные типы (Opaque types) и ключевое слово some   461
//вращаемого функцией getCar значения, а знаете лишь то, что оно соответствует
//протоколу Vehicle). Это приведет к ошибке Runtime, однако компиляция программы пройдет корректно (рис. 34.4).


//Использование дженерика в данном случае было бы оправданно, если бы протокол Vehicle не имел ассоциированных типов, а функция getCar могла бы вернуть
//значения любого подходящего типа (листинг 34.26).


//protocol Vehicle {
// var uid: Int { get set }
// // инициализатор
// init()
//}
//struct Car: Vehicle {
// var uid: Int = 0
//}
//struct Truck: Vehicle {
// var uid: String = ""
//}
//func getObject<T: Vehicle>() -> T {
// return T()
//}
//let car: Car = getObject() // Car
//let truck: Truck = getObject() // Truck


//В зависимости от того, какой тип данных имеет принимающий параметр, функция
//вернет корректное значение требуемого типа. При использовании дженериков тип
//данных итогового значения определяется при вызове функции.


//Использовать непрозрачные типы (Opaque types).
//При реализации функции getCar тип возвращаемого значения может быть указан
//как протокол Vehicle с ключевым словом some (листинг 34.27).
//Листинг 34.27
func getCar() -> some Vehicle {
 return Car(uid: 54)
}
let myCar = getCar() // Car
//Ключевое слово some говорит о том, что Vehicle является непрозрачным типом
//(Opaque type), с помощью чего компилятор заранее анализирует тело функции
//и определяет конкретный тип возвращаемого значения.
//Но в чем суть Opaque types, неужели это действительно так необходимо? Почему мы должны использовать ключевое слово some, если вариант с дженериком
//вполне работает?
//Универсальные шаблоны (дженерики) и непрозрачные типы связаны между
//собой. Можно сказать, что непрозрачные типы — это обратные универсальные
//шаблоны. При использовании дженериков конкретный тип возвращаемого значения определяет тот, кто вызывает функцию, а при использовании Opaque types
//конкретный тип определяется реализацией функции (в ее теле) (листинг 34.28).
//Листинг 34.28
//
// Generic
//
//func getCar<T: Vehicle>() -> T{
// return Car(uid: 22) as! T
//}
// Тип возвращаемого значения определяется тут
//let a: Car = getCar()
//
// Opaque type
//
func getCar() -> some Vehicle {
 // Тип возвращаемого значения определяется тут
 return Car(uid: 54)
}
let b = getCar() // Car
//В первом случае заполнитель типа (T) заменяется на конкретный тип данных при
//вызове функции. В свою очередь, при использовании Opaque type тип данных
//возвращаемого значения определяется в ходе анализа функции еще до ее вызова.
//34.6. Непрозрачные типы (Opaque types) и ключевое слово some   463
//Другими словами, с помощью some мы скрываем от пользователя (того, кто вызывает функцию) информацию о конкретном типе возвращаемых данных. При
//этом этот тип данных определяется в теле функции. На рис. 34.5 видно, что в окне
//автодополнения при вызове функции указывается Vehicle вместо конкретного
//типа, однако после вызова функции в константе b находится значение конкретного типа Car.
//Рис. 34.5. Opaque types в действии
//Функция, использующая непрозрачный тип, всегда будет возвращать значение
//одного конкретного типа данных. Таким образом, код, показанный в листинге 34.29, недопустим.
//Листинг 34.29
func getCar(by number: Int) -> some Vehicle {
 switch number {
 case 1:
 return Car(uid: 55)
 default:
 return Truck(uid: "0X882S1")
 }
}
// ОШИБКА! Такой код недопустим, так как функция должна возвращать значение
//конкретного типа данных, а не одного из ...
//Обратите особое внимание на пример выше. Непрозрачные типы обеспечивают
//идентичность типов, то есть функция, использующая Opaque type, возвращает
//464   Глава 34. Универсальные шаблоны (Generic)
//значение одного конкретного (повторю: конкретного) типа данных, просто до ее
//вызова вы не знаете, какого именно.
//Появление непрозрачных типов в Swift позволяет скрывать от пользователя библиотек (или фреймворков) их внутреннюю реализацию.
//Как уже говорилось ранее, при использовании дженериков пользователь библиотеки (программист, использующий реализованную в библиотеке функцию) должен самостоятельно указать тип данных возвращаемого дженериком значения
//(листинг 34.30).
//Листинг 34.30
//func getCar<T: Vehicle>() -> T{
// return Car(uid: 22) as! T
//}
//let a: Car = getCar()
//let b = getCar() // ОШИБКА, Тип не указан
//Таким образом, определение типа отдается на откуп пользователю. При использовании Opaque types компилятор самостоятельно определяет тип возвращаемого
//значения, а пользователь просто использует функцию, ничего не зная о типе
//данных, который она возвращает.
//Резюмируем все вышесказанное:
// Opaque types позволяют указывать тип возвращаемого функцией значения
//с помощью протокола, использующего связанные типы (или ключевое слово
//Self) в своей реализации.
// Opaque types позволяют определять тип возвращаемого значения внутри самой
//функции.
//Opaque types (непрозрачные типы) — это одно из значительных нововведений
//Swift. В дальнейшем вы еще неоднократно встретитесь с этим механизмом, в том
//числе при изучении фреймворка SwiftUI, знакомству с которым посвящена гла
