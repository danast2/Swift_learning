//
//  memory_management.swift
//  Swift_learning
//
//  Created by Даниил Асташов on 24.10.2024.
//

import Foundation


//Управление памятью (memory management) — это одна из тем теоретических основ программирования. Конечно, даже совершенно ничего не понимая в том, как
//происходит работа по выделению и освобождению памяти вашего компьютера,
//вы сможете писать вполне работоспособные программы. Однако:
//1. Недостаток знаний может привести к большим проблемам, а именно к утечкам памяти и, возможно, последующему падению производительности, критическим ошибкам и аварийному завершению ваших приложений.
//2. Если вы будете проходить собеседование на должность Junior Swift Developer,
//вас могут спросить о том, а что же такое стек (stack), чем он отличается от
//кучи (heap) и как в них хранятся значения различных типов данных. И вам
//ни в коем случае нельзя ударить в грязь лицом.
//ПРИМЕЧАНИЕ Утечка памяти — это программная ошибка, приводящая к излишнему расходованию оперативной памяти.


//что такое управление памятью

//Любое приложение в процессе функционирования использует оперативную
//память. Очень важно, чтобы этот процесс, с одной стороны, был максимально
//быстр и не заметен для пользователя, а с другой — чтобы ресурсы своевременно освобождались, не превращая все доступное пространство в некое подобие
//«кладбища», где хранятся объекты, которые никогда не будут использоваться
//в дальнейшем.
//Основную работу по распределению и очистке памяти Swift совместно с операционной системой (например, iOS или macOS) производит самостоятельно, без
//участия разработчика. Вы просто пишете код, компилируете его, и он работает.
//При этом все создаваемые в приложении значения корректно и быстро записываются в память и извлекаются из нее, не требуя от вас каких-либо специальных
//знаний.
//Я бы хотел подробнее рассказать вам об этих процессах, опуститься на уровень
//ниже и разобраться с тем, как в оперативной памяти организовано хранение
//данных.
//28.1. Что такое управление памятью   381
//Как вы знаете, память представляет собой множество ячеек. В первых главах книги мы уже знакомились с ее упрощенной структурой. Тогда был показан пример,
//в котором каждая ячейка представлялась некоей структурой, способной хранить
//одно конкретное значение. В действительности все несколько сложнее.
//Типовая ячейка оперативной памяти построена на основе полупроводниковых
//электронных компонентов (транзисторов и конденсаторов), объединенных
//в группу. Она способна хранить значения размером в 1 байт, то есть 8 бит (8 нулей
//и единиц). На одной планке памяти расположены миллиарды таких ячеек, и для
//навигации каждая из них имеет уникальный порядковый номер, который является
//ее физическим адресом (рис. 28.1). По данному адресу ячейка может быть найдена
//во всем множестве ячеек, доступных в памяти



//От того, какое именно значение сохраняется в памяти, зависит количество ячеек,
//которое оно будет занимать. Так, значение типа UInt16 займет всего 2 ячейки,
//так как для него требуется 2 байта, то есть 16 бит (216 = 65 535 — максимальное
//значение, которое может храниться в параметре типа UInt16).
//Но для того, чтобы программы могли взаимодействовать с этими физическими
//ячейками, необходим подходящий механизм, которым является виртуальная
//память. Виртуальная память объединяет первичную (оперативная память) и вторичную (жесткий диск или SSD для хранения файлов подкачки) память в единое
//хранилище со сквозным адресным пространством.
//Как только в операционной системе запускается новый процесс (например, ваше
//приложение), ему выделяется персональный участок виртуальной памяти, который будет использоваться в процессе функционирования. Благодаря наличию
//382   Глава 28. Управление памятью в Swift
//виртуальной памяти приложения защищены от воздействия на участки друг
//друга. Работая с памятью в своем приложении, вы взаимодействуете только с теми
//ячейками, которые были выделены именно вам.
//Выделенная вашему приложению память логически делится на три области:
//1. Статическая память, в которой размещается код приложения, различные библиотеки, метаданные и глобальные переменные, необходимые для работы.
//2. Автоматическая память, в которой хранятся все локальные для текущей области видимости параметры.
//3. Динамическая память, в которой память выделяется динамически по запросу

//Статическая память
//В процессе компиляции ваше приложение переводится в машинный код, то есть
//код, понятный компьютеру. А в процессе загрузки этот код, вместе с различными
//библиотеками, загружается в статическую область памяти, откуда по мере необходимости вызывается. Статическая память выделяется один раз еще до появления
//приложения на экране и существует все время, пока приложение работает.
//Автоматическая память
//Автоматическая память работает на основе структуры данных стек (stack), то есть
//по принципу «последним пришел — первым вышел» (Last in, first out, или LIFO).
//Объекты, записанные в стек, похожи на стопку тарелок: последняя поставленная
//тарелка не дает убрать те, что находятся ниже, пока данная тарелка сама не будет
//убрана.
//В стеке хранятся все локальные (относящиеся к данной области видимости)
//значения. То есть как только создается новая переменная, она помещается в стек,
//следующая переменная помещается поверх нее, и т. д. А при выходе из данной
//области видимости все созданные значения последовательно удаляются из стека.
//ПРИМЕЧАНИЕ Стек — это лишь способ хранения параметров и их значений. Это не значит,
//что у вас при этом есть доступ только к верхнему элементу стека. Ваше приложение всегда
//хранит ссылки на адреса всех параметров, и вы при необходимости можете получить доступ
//к любому из них (в соответствии с их областью видимости) для их чтения или изменения. Но
//удаляются элементы стека последовательно.
//В Swift в стеке хранятся значимые типы данных (value type), а также указатели на
//ссылочные типы (reference type). Работая со стеком, вы не встретитесь с какимилибо проблемами излишнего использованием памяти: его элементы своевременно
//создаются и удаляются.


// структура, описывающая сущность "Приложение"
struct Application {
 var name: String
}

// функция, производящая загрузку ресурсов
func loadResources(forApp: Application) {
 let appPath = "./bin/\(forApp.name)/"
 // ... последующие операции внутри функции
}

// функция — точка входа в приложение
func main(testMode: Bool) {
 let app = Application(name: "Calculator")
 // ... последующие операции внутри функции
}
// начало работы программы
//main(testMode: true)

//Структура Application и функция main(testMode:) после загрузки будут находиться в статической памяти. В ходе работы приложения по мере необходимости
//они будут вызваны оттуда.
//Как только в программе создается новая область видимости (scope) — в данном
//случае вызывается функция main, — в стеке создается новый фрейм (специальный
//блок, объединяющий несколько элементов одной области видимости), в котором
//выделяется место под локальные для этой области видимости параметры и их
//значения (рис. 28.2)


// функция — точка входа
func main_n(testMode: Bool) {
 let app = Application(name: "Calculator")
 loadResources(forApp: app)
 // ... последующие операции внутри функции
}
// начало работы программы
//main(testMode: true)


//Теперь работа с памятью будет включать следующие шаги (рис. 28.3):
//1. В момент вызова функции main в стеке создается новый фрейм, в который помещаются значения локальных параметров testMode и app.
//2. В момент вызова функции loadResources(forApp:) в стеке создается второй фрейм, в который помещаются значения локальных параметров forApp
//и appPath.
//3. Как только функция loadResources завершает работу, из стека последовательно удаляются все объекты, относящиеся к данной области видимости.
//4. Как только функция main завершает работу, из стека также удаляются все
//объекты, связанные с ней


//Аргумент forApp функции loadResources, а также локальный параметр appPath —
//это value type, а значит, они также сохраняются в стеке.
//Приложение знает, где находится вершина стека (оно хранит адрес верхнего значения в стеке), а фреймы хранят информацию о предыдущем фрейме. Благодаря
//этому работа со стеком очень быстрая, практически мгновенная. При необходимости удалить фрейм у стека просто изменяется указатель на верхний элемент
//(на шаге 3 вместо appPath верхним элементом стал app).


//Динамическая память
//Но что будет, если вместо структуры Application использовать одноименный
//класс, ведь класс — это reference type, его значения передаются по ссылке, а не
//копированием, как в случае со структурой. Для хранения значений ссылочных
//типов используется динамическая память.
//Динамическая память — это область, память в которой выделяется по запросу
//приложения. Данная область также называется кучей (heap). Объекты в куче
//не упорядочены, программа при необходимости захватывает память требуемого
//объема и помещает туда значение. При этом в стеке создается запись, в которой
//сохраняется ссылка на объект в куче.
//Вместо структуры Application из предыдущего листинга используем одноименный класс, при этом объявим в нем деинициализатор и добавим несколько вызовов
//функции print, чтобы отследить, когда именно создается и удаляется экземпляр
//(листинг 28.3).


class Application_p {
 var name: String
 init(name: String) {
 print("создание экземпляра")
 self.name = name
 }
 deinit {
 print("уничтожение экземпляра")
 }
}
func loadResources_p(forApp: Application) {
 print("начало функции loadResources")
 let appPath = "./bin/\(forApp.name)/"
 // ... последующие операции внутри функции
 print("завершение функции loadResources")
}
// функция — точка входа
func main_p(testMode: Bool) {
    print("начало функции main")
     let app = Application(name: "Calculator")
     loadResources(forApp: app)
     // ... последующие операции внутри функции
     print("завершение функции main")
    }
    // начало работы программы
    //main(testMode: true)


//начало функции main
//создание экземпляра
//начало функции loadResources
//завершение функции loadResources
//завершение функции main
//уничтожение экземпляра
//Обратите внимание на консоль: самое интересное, что объект типа Application
//уничтожается лишь в самом конце, после того, как функция main завершает свою
//работу.
//Разберем порядок работы кода по шагам (рис. 28.4):
//1. В момент вызова функции main в стеке создается новый фрейм, в который
//помещаются значения локальных параметров. При этом значение типа
//Application (это ссылочный тип) сохраняется в куче, а в стеке создается
//запись со ссылкой на него.
//2. В момент вызова функции loadResources(forApp:) в стеке создается второй
//фрейм, в который помещаются значения локальных параметров. При этом
//значение типа Application передано по ссылке, а не копированием, поэтому
//в стеке создается новая запись, содержащая ссылку на уже существующее
//значение в куче.
//3. Как только функция loadResources завершает работу, из стека последовательно удаляются все объекты, относящиеся к данной области видимости,
//включая ссылку на объект типа Application, хранящийся в куче. Но сам объект Application в куче не удаляется.
//4. Как только функция main завершает работу, из стека также удаляются все
//объекты, связанные с ней, включая ссылку на объект типа Application, хранящийся в куче.
//5. Объект типа Application в куче больше не имеет входящих ссылок, а значит,
//может быть удален. Это происходит в автоматическом режиме с помощью
//встроенного в Swift механизма ARC (Automatic Reference Counting), с которым мы познакомимся в конце главы.
//Все проблемы, связанные с излишним использованием памяти в ваших приложениях, случаются только из-за неправильного использования ссылок на объекты
//в куче; чуть позже мы искусственно создадим утечку памяти, после чего рассмотрим способы избежать этого




//28.2. Уничтожение экземпляров
//Стандартный цикл жизни экземпляров объектных типов состоит из следующих
//шагов:
//1) выделение памяти (в стеке или в куче);
//2) инициализация (выполнение кода в методе init);
//3) использование;
//4) деинициализация (выполнение кода в методе deinit, актуально только для
//классов);
//5) освобождение памяти.
//388   Глава 28. Управление памятью в Swift
//Как говорилось в предыдущем разделе, Swift принимает решение об удалении
//значения в памяти, основываясь на том, когда происходит выход из области
//видимости (например, завершается функция). Когда речь идет о стеке, то просто последовательно удаляются все значения, находящиеся в соответствующем
//фрейме. Значимые типы практически никогда не создают каких-либо проблем
//с памятью, так как хранятся в стеке.
//Но как обстоит ситуация с кучей? Каким образом Swift принимает решение о том,
//что экземпляры классов могут быть удалены? Для этого специальный механизм
//ARC ведет подсчет ссылок на каждый объект в куче, и в случае, если их количество
//равняется нулю, объект удаляется из памяти.


//Количество ссылок на экземпляр
//Рассмотрим пример из листинга 28.4.
//Листинг 28.4
class House {
 var title: String
 var owner: Human?
 init(title: String, owner: Human? = nil) {
 print("Дом \(title) создан")
 self.title = title
 self.owner = owner
 return
 }
 deinit{
 print("Дом \(title) уничтожен")
 }
}
class Human {
 var name: String
 init(name: String) {
 print("Владелец \(name) создан")
 self.name = name
 return
 }

 deinit {
 print("Владелец \(name) уничтожен")
 }
}
//Класс House описывает сущность «Дом», а класс Human — сущность «Человек».
//Человек может быть владельцем дома, в этом случае он указывается в свойстве
//owner. Предположим, что некий человек является владельцем двух домов (листинг 28.5).


// создаем область видимости
//if true { // шаг 1
// let houseOwner = Human(name:"Василий")
// if true { // шаг 2
// let house = House(title:"Частный дом", owner: houseOwner)
// } // шаг 3
// // шаг 4
// let secondHouse = House(title: "Квартира", owner: houseOwner)
//} // шаг 5


//Владелец Василий создан
//Дом Частный дом создан
//Дом Частный дом уничтожен
//Дом Квартира создан
//Дом Квартира уничтожен
//Владелец Василий уничтожен
//ПРИМЕЧАНИЕ Конструкция if в данном примере используется только для того, чтобы
//создать новую область видимости, при выходе из которой должны удаляться записанные в память объекты.
//Рассмотрим по шагам, как именно работает данный код (рис. 28.5):
//1. В куче выделяется память под новый объект ссылочного типа, описывающий
//владельца (Василий). В стеке создается новый фрейм, в котором выделяется
//память под константу houseOwner, содержащую указатель на объект «Василий» в куче.
//2. В куче создается новый объект типа House, содержащий в свойстве owner
//ссылку на уже существующий объект типа Human (передается в качестве аргумента инициализатора). В стеке создается новый фрейм (#2), в котором
//выделяется память для константы house, содержащей ссылку на объект типа
//House (Частный дом) в куче.
//3. Происходит выход из области видимости (вложенный оператор if), вследствие чего в стеке удаляется фрейм (#2), а также его элементы и ссылка на
//объект House (Частный дом) в куче. Данный объект в куче также автоматически удаляется, так как у него больше нет входящих ссылок. Следовательно,
//удаляется ссылка на объект типа Human, которая хранилась в свойстве owner.
//4. Обратите внимание, что при этом объект типа Human не удаляется, так у него
//все еще существует входящая ссылка из стека.
//5. В куче создается новый объект типа House (Квартира). В стеке, в уже существующем фрейме (#1) (так как это та же самая область видимости), создается параметр secondHouse, содержащий ссылку на объект в куче.
//6. Оператор if завершает свою работу, а значит, происходит выход из соответствующей области видимости. По этой причине последовательно удаляются
//элементы фрейма #1 в стеке. После этого удаляется объект House (Квартира), так как на него больше нет ссылок. В последнюю очередь удаляется объект типа Human (Василий), так как последняя ссылка на него исчезла вместе
//с House (Квартира).


//28.3. Утечки памяти и ARC
//Одна из наиболее серьезных проблем, которая может возникнуть в процессе
//разработки приложений, — это утечка памяти. Некоторые утечки практически
//не заметны, а из-за некоторых вы лишаетесь значительного объема доступной
//памяти. А это, в свою очередь, чревато падением производительности и экстренным завершением приложения.
//При утечке памяти Swift не может принять своевременное решение об удалении
//объектов в куче. В результате этого в памяти появляются «бесхозные» записи,
//которые никогда больше не будут использоваться и будут находиться там до завершения работы приложения.
//Пример утечки памяти
//Рассмотрим ситуацию, при которой может возникнуть утечка памяти. Изменим
//объявленные ранее классы House и Human так, чтобы Human также мог хранить
//ссылки на дома, чьим владельцем он является (листинг 28.6). То есть создадим
//возможность создания кольцевых ссылок, когда объекты взаимно указывают
//друг на друга.
class Human_n {
 var name: String
 var houses: [House] = []
 init(name: String) {
     print("Владелец \(name) создан")
     self.name = name
     return
 }
 func add(house: House) {
     self.houses.append(house)
 }
 deinit {
     print("Владелец \(name) уничтожен")
 }
}


//C помощью метода add(house:) мы можем установить дополнительную связь
//между домом и его владельцем: если раньше главным объектом была сущность
//«Дом», так как содержала ссылку на владельца, то теперь связь двусторонняя.
//Рассмотрим пример из листинга 28.7



/*
// создаем область видимости
if true { // шаг 1
 let houseOwner = Human(name:"Василий")
 if true { // шаг 2
     let house = House(title:"Частный дом", owner: houseOwner)
     houseOwner.add(house: house)
 } // шаг 3
 // шаг 4
 let secondHouse = House(title: "Квартира", owner: houseOwner)
 houseOwner.add(house: secondHouse)
} // шаг 5
*/


//Консоль
//Владелец Василий создан
//Дом Частный дом создан
//Дом Квартира создан
//Если посмотреть на вывод на консоли, то вы увидите, что все три объекта
//(houseOwner, house и secondHouse) были созданы. Но хотя код и завершил работу
//392   Глава 28. Управление памятью в Swift
//без ошибок, они так и не были удалены (деинициализатор ни в одном из них не был
//вызван). Это пример утечки памяти: происходил выход из областей видимости,
//но локальные параметры не удалялись.
//Для того чтобы разобраться, в чем причина такого поведения, рассмотрим работу
//кода по шагам (рис. 28.6):
//1. В куче выделяется память под новый объект ссылочного типа, описывающий владельца (Василий). В стеке создается новый фрейм, в котором выделяется память под константу houseOwner, содержащую указатель на данный
//объект.
//2. В куче создается новый объект house, который в свойстве owner содержит
//ссылку на уже существующий объект типа Human. В стеке создается новый
//фрейм (#2), в котором выделяется память для константы house, содержащей
//ссылку на объект тип House (Частный дом). При этом в свойство houses параметра houseOwner добавляется ссылка на созданный «Частный дом».
//3. Происходит выход из области видимости (вложенный оператор if), вследствие чего в стеке удаляется фрейм (#2) и все его элементы. Но самое интересное, что объект типа House (Частный дом) в куче не может быть удален, так как на него все еще ссылается объект houseOwner. И несмотря на то
//что был произведен выход из области видимости, объект остается «висеть»
//в памяти.
//4. В куче создается новый объект типа House (Квартира). В стеке в уже существующем фрейме (#1) создается объект secondHouse, содержащий ссылку на
//объект в куче. При этом создается взаимная ссылка от параметра houseOwner
//к созданному объекту.
//5. Оператор if завершает свою работу, а значит, происходит выход из соответствующей области видимости. По этой причине последовательно удаляются
//элементы фрейма #1 в стеке, но ни один из элементов в куче не может быть
//удален, так как они имеют взаимные ссылки друг на друга.
//Подобная ситуация называется циклом сильных ссылок (retain cycle). В этом
//случае Swift просто не может решить, какую из ссылок можно уничтожить,
//а какую нет. В результате все объекты имеют входящие ссылки и не удаляются
//из памяти.
//Это типичный пример утечки памяти в приложениях


//Сильные (strong), слабые (weak) и бесхозные (unowned)
//ссылки
//Все создаваемые по умолчанию ссылки на объекты являются сильными (strong).
//Если объект имеет хотя бы одну входящую сильную ссылку, то он просто не может
//быть удален.
//Для решения показанной ранее ситуации с утечкой памяти в Swift используются
//слабые ссылки. Такой вид ссылок не мешает удалению объекта, то есть если объект
//в куче имеет входящие слабые ссылки, но не имеет входящих сильных ссылок, то
//будет удален, как только для этого возникнут подходящие условия (произойдет
//выход из области видимости).
//Для того чтобы пометить ссылку как сильную, вам не нужно использовать специальные ключевые слова. Для слабых ссылок предназначен модификатор weak,
//который указывается перед объявлением свойства, содержащего ссылку:
//weak var имяСвойства: ОпциональныйТипДанных?
//Данный модификатор говорит о том, что по усмотрению Swift значение свойства
//может быть переведено в nil, то есть уничтожено.
//Внесем изменения в класс House и сделаем ссылку на владельца (свойство owner)
//слабой (weak) (листинг 28.8).


class House_l {
 var title: String
 weak var owner: Human?
 init(title: String, owner: Human? = nil) {
     print("Дом \(title) создан")
     self.title = title
     self.owner = owner
     return
 }
 deinit {
     print("Дом \(title) уничтожен")
 }
}


//Теперь, если вновь запустить код из листинга 28.7, то на консоли вы увидите
//следующее:
//Консоль
//Владелец Василий создан
//Дом Частный дом создан
//Дом Квартира создан
//Владелец Василий уничтожен
//Дом Частный дом уничтожен
//Дом Квартира уничтожен
//Все объекты уничтожены, а это значит, что никаких утечек памяти больше нет.
//Разберем листинг 28.7 по шагам (рис. 28.7).
//1. В куче выделяется память под новый объект ссылочного типа, описывающий
//владельца (Василий). В стеке создается новый фрейм, в котором выделяется
//память под константу houseOwner, содержащую ссылку на объект «Василий».
//2. В куче создается новый объект типа House, содержащий в свойстве owner слабую ссылку на уже существующий объект типа Human. В стеке создается новый фрейм (#2), в котором выделяется память для константы house, содержащей ссылку на объект тип House (Частный дом). При этом в свойство houses
//параметра houseOwner добавляется ссылка на созданный «Частный дом».
//3. Происходит выход из области видимости (вложенный оператор if), вследствие чего в стеке удаляется фрейм (#2) и все его элементы. При этом объект
//типа House (Частный дом) в куче не может быть удален, так как на него ссылается объект houseOwner.
//4. В куче создается новый объект типа House (Квартира). В стеке, в уже существующем фрейме (#1), создается объект secondHouse, содержащий слабую
//ссылку на объект в куче. При этом создается взаимная ссылка от параметра
//houseOwner к созданному объекту


//5. Оператор if завершает свою работу, и происходит выход из соответствующей
//области видимости. По этой причине последовательно удаляются элементы
//фрейма #1 в стеке. В куче все еще находятся три объекта, взаимно ссылающиеся друг на друга. Swift видит данную ситуацию и изменяет значение, хранящееся по слабой ссылке (свойства owner в типах House) на nil, тем самым
//уничтожая объект типа Human.
//6. Два оставшихся объекта типа House теперь не имеют входящих сильных
//ссылок, а значит, могут быть безболезненно удалены, что и происходит.
//Использование модификатора weak привносит некоторые особенности:
// Так как значение свойства переводится в nil, оно должно быть опциональным.
//В нашем примере свойство owner имеет опциональный тип Human?.
// Так как свойство изменяет свое значение (на nil), оно не может быть константой.
//396   Глава 28. Управление памятью в Swift
//Если необходимо сделать слабую ссылку на экземпляр неопционального типа
//данных, то используется модификатор unowned вместо weak (листинг 28.9). Такие
//ссылки называются бесхозными.


class House_m {
 var title: String
 unowned var owner: Human
 init(title: String, owner: Human) {
     print("Дом \(title) создан")
     self.title = title
     self.owner = owner
     return
 }
 deinit {
     print("Дом \(title) уничтожен")
 }
}


//Automatic Reference Counting (ARC)
//Automatic Reference Counting (ARC) — это специальный механизм автоматического подсчета ссылок. Именно он подсчитывал количество входящих сильных
//ссылок на каждый объект и при возможности удалял неиспользуемые экземпляры.
//Всю «магию», о которой мы говорили в данной главе, реализует именно ARC. Как
//только последняя ссылка на экземпляр будет удалена и произойдет выход из ее
//области видимости, ARC незамедлительно вызовет деинициализатор и уничтожит объект.
//ARC делает работу со Swift еще более удобной.
//28.4. Ссылки в замыканиях
//В процессе изучения материала мы неоднократно говорили о том, что value
//type передается копированием, а reference type — по ссылке. И это утверждение истинно практически в 100% случаев, но если на одном из будущих
//собеседований вас спросят: «А может ли value type передаваться по ссылке?»
//и вы ответите: «Нет! Не может!», то, вероятно, не пройдете его. В этом разделе
//28.4. Ссылки в замыканиях   397
//я покажу вам простейший пример того, что и значимые типы могут быть переданы по ссылке.
//ПРИМЕЧАНИЕ На самом деле вы уже знаете этот материал, но до этого при его рассмотрении
//я не акцентировал внимание именно на таком поведении значимых типов.
//Взгляните на листинг 28.10.
//Листинг 28.10
//var a = 2
//let f = { print(a) }
//f()
//a = 3
//f()
//Консоль
//2
//3
//Это пример уже известного вам захвата переменных замыканиями. В нем мы
//создаем параметр типа Int и выводим его значение на консоль с помощью замыкания f. Обратите внимание на то, что Int — это структура, следовательно,
//value type, значение которого должно передаваться копированием. Но при этом
//замыкание f всегда выводит актуальное значение параметра. Это говорит о том,
//что внутри замыкания используется не копия параметра a, а ссылка на него!


//Это и есть пример того, как значимый тип данных может быть передан по ссылке.
//Запомните, что замыкания всегда захватывают значения по ссылке, а не копированием! Даже значение value type!
//Такое поведение также может быть для вас неочевидным и стать источником
//проблем, в частности, в результате несвоевременного удаления объектов, захваченных в замыканиях. Но и в этом случае можно использовать модификаторы
//weak и unowned для изменения типа ссылки для входных аргументов замыканий.
//Рассмотрим пример из листинга 28.11, в котором создается пустое опциональное
//замыкание и в зоне ограниченной области видимости (в теле оператора if) ему
//передается значение (тело замыкания).
