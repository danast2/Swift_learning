//
//  memory_management.swift
//  Swift_learning
//
//  Created by Даниил Асташов on 24.10.2024.
//

import Foundation


//Управление памятью (memory management) — это одна из тем теоретических основ программирования. Конечно, даже совершенно ничего не понимая в том, как
//происходит работа по выделению и освобождению памяти вашего компьютера,
//вы сможете писать вполне работоспособные программы. Однако:
//1. Недостаток знаний может привести к большим проблемам, а именно к утечкам памяти и, возможно, последующему падению производительности, критическим ошибкам и аварийному завершению ваших приложений.
//2. Если вы будете проходить собеседование на должность Junior Swift Developer,
//вас могут спросить о том, а что же такое стек (stack), чем он отличается от
//кучи (heap) и как в них хранятся значения различных типов данных. И вам
//ни в коем случае нельзя ударить в грязь лицом.
//ПРИМЕЧАНИЕ Утечка памяти — это программная ошибка, приводящая к излишнему расходованию оперативной памяти.


//что такое управление памятью

//Любое приложение в процессе функционирования использует оперативную
//память. Очень важно, чтобы этот процесс, с одной стороны, был максимально
//быстр и не заметен для пользователя, а с другой — чтобы ресурсы своевременно освобождались, не превращая все доступное пространство в некое подобие
//«кладбища», где хранятся объекты, которые никогда не будут использоваться
//в дальнейшем.
//Основную работу по распределению и очистке памяти Swift совместно с операционной системой (например, iOS или macOS) производит самостоятельно, без
//участия разработчика. Вы просто пишете код, компилируете его, и он работает.
//При этом все создаваемые в приложении значения корректно и быстро записываются в память и извлекаются из нее, не требуя от вас каких-либо специальных
//знаний.
//Я бы хотел подробнее рассказать вам об этих процессах, опуститься на уровень
//ниже и разобраться с тем, как в оперативной памяти организовано хранение
//данных.
//28.1. Что такое управление памятью   381
//Как вы знаете, память представляет собой множество ячеек. В первых главах книги мы уже знакомились с ее упрощенной структурой. Тогда был показан пример,
//в котором каждая ячейка представлялась некоей структурой, способной хранить
//одно конкретное значение. В действительности все несколько сложнее.
//Типовая ячейка оперативной памяти построена на основе полупроводниковых
//электронных компонентов (транзисторов и конденсаторов), объединенных
//в группу. Она способна хранить значения размером в 1 байт, то есть 8 бит (8 нулей
//и единиц). На одной планке памяти расположены миллиарды таких ячеек, и для
//навигации каждая из них имеет уникальный порядковый номер, который является
//ее физическим адресом (рис. 28.1). По данному адресу ячейка может быть найдена
//во всем множестве ячеек, доступных в памяти



//От того, какое именно значение сохраняется в памяти, зависит количество ячеек,
//которое оно будет занимать. Так, значение типа UInt16 займет всего 2 ячейки,
//так как для него требуется 2 байта, то есть 16 бит (216 = 65 535 — максимальное
//значение, которое может храниться в параметре типа UInt16).
//Но для того, чтобы программы могли взаимодействовать с этими физическими
//ячейками, необходим подходящий механизм, которым является виртуальная
//память. Виртуальная память объединяет первичную (оперативная память) и вторичную (жесткий диск или SSD для хранения файлов подкачки) память в единое
//хранилище со сквозным адресным пространством.
//Как только в операционной системе запускается новый процесс (например, ваше
//приложение), ему выделяется персональный участок виртуальной памяти, который будет использоваться в процессе функционирования. Благодаря наличию
//382   Глава 28. Управление памятью в Swift
//виртуальной памяти приложения защищены от воздействия на участки друг
//друга. Работая с памятью в своем приложении, вы взаимодействуете только с теми
//ячейками, которые были выделены именно вам.
//Выделенная вашему приложению память логически делится на три области:
//1. Статическая память, в которой размещается код приложения, различные библиотеки, метаданные и глобальные переменные, необходимые для работы.
//2. Автоматическая память, в которой хранятся все локальные для текущей области видимости параметры.
//3. Динамическая память, в которой память выделяется динамически по запросу

//Статическая память
//В процессе компиляции ваше приложение переводится в машинный код, то есть
//код, понятный компьютеру. А в процессе загрузки этот код, вместе с различными
//библиотеками, загружается в статическую область памяти, откуда по мере необходимости вызывается. Статическая память выделяется один раз еще до появления
//приложения на экране и существует все время, пока приложение работает.
//Автоматическая память
//Автоматическая память работает на основе структуры данных стек (stack), то есть
//по принципу «последним пришел — первым вышел» (Last in, first out, или LIFO).
//Объекты, записанные в стек, похожи на стопку тарелок: последняя поставленная
//тарелка не дает убрать те, что находятся ниже, пока данная тарелка сама не будет
//убрана.
//В стеке хранятся все локальные (относящиеся к данной области видимости)
//значения. То есть как только создается новая переменная, она помещается в стек,
//следующая переменная помещается поверх нее, и т. д. А при выходе из данной
//области видимости все созданные значения последовательно удаляются из стека.
//ПРИМЕЧАНИЕ Стек — это лишь способ хранения параметров и их значений. Это не значит,
//что у вас при этом есть доступ только к верхнему элементу стека. Ваше приложение всегда
//хранит ссылки на адреса всех параметров, и вы при необходимости можете получить доступ
//к любому из них (в соответствии с их областью видимости) для их чтения или изменения. Но
//удаляются элементы стека последовательно.
//В Swift в стеке хранятся значимые типы данных (value type), а также указатели на
//ссылочные типы (reference type). Работая со стеком, вы не встретитесь с какимилибо проблемами излишнего использованием памяти: его элементы своевременно
//создаются и удаляются.


// структура, описывающая сущность "Приложение"
struct Application {
 var name: String
}

// функция, производящая загрузку ресурсов
func loadResources(forApp: Application) {
 let appPath = "./bin/\(forApp.name)/"
 // ... последующие операции внутри функции
}

// функция — точка входа в приложение
func main(testMode: Bool) {
 let app = Application(name: "Calculator")
 // ... последующие операции внутри функции
}
// начало работы программы
//main(testMode: true)

//Структура Application и функция main(testMode:) после загрузки будут находиться в статической памяти. В ходе работы приложения по мере необходимости
//они будут вызваны оттуда.
//Как только в программе создается новая область видимости (scope) — в данном
//случае вызывается функция main, — в стеке создается новый фрейм (специальный
//блок, объединяющий несколько элементов одной области видимости), в котором
//выделяется место под локальные для этой области видимости параметры и их
//значения (рис. 28.2)


// функция — точка входа
func main_n(testMode: Bool) {
 let app = Application(name: "Calculator")
 loadResources(forApp: app)
 // ... последующие операции внутри функции
}
// начало работы программы
//main(testMode: true)


//Теперь работа с памятью будет включать следующие шаги (рис. 28.3):
//1. В момент вызова функции main в стеке создается новый фрейм, в который помещаются значения локальных параметров testMode и app.
//2. В момент вызова функции loadResources(forApp:) в стеке создается второй фрейм, в который помещаются значения локальных параметров forApp
//и appPath.
//3. Как только функция loadResources завершает работу, из стека последовательно удаляются все объекты, относящиеся к данной области видимости.
//4. Как только функция main завершает работу, из стека также удаляются все
//объекты, связанные с ней


//Аргумент forApp функции loadResources, а также локальный параметр appPath —
//это value type, а значит, они также сохраняются в стеке.
//Приложение знает, где находится вершина стека (оно хранит адрес верхнего значения в стеке), а фреймы хранят информацию о предыдущем фрейме. Благодаря
//этому работа со стеком очень быстрая, практически мгновенная. При необходимости удалить фрейм у стека просто изменяется указатель на верхний элемент
//(на шаге 3 вместо appPath верхним элементом стал app).
