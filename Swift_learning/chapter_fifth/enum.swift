//
//  enum.swift
//  Swift_learning
//
//  Created by Даниил Асташов on 22.10.2024.
//

import Foundation

//Перечисление (enum) — это объектный тип данных, который предоставляет доступ к различным предопределенным значениям. Рассматривайте его как перечень возможных значений, то есть набор констант, значения которых являются
//альтернативами друг другу.
//Рассмотрим хранилище, которое описывает некоторую денежную единицу (листинг 19.1). Для того чтобы решить поставленную задачу с помощью изученных
//ранее типов данных, можно использовать тип String. В этом случае потребуется
//вести учет всех возможных значений для описания денежных единиц

var russianCurrency: String = "Rouble"

//Подобный подход создает проблем больше, чем позволяет решить, поскольку не
//исключает влияния человеческого фактора, из-за которого случайное изменение
//всего лишь одной буквы приведет к тому, что программа не сможет корректно
//обработать поступившее значение. А что делать, если потребуется добавить обработку нового значения денежной единицы?
//Альтернативой этому способу может служить создание коллекции, например
//массива (листинг 19.2). Массив содержит все возможные значения, которые
//доступны в программе. При необходимости происходит получение требуемого
//элемента массива.

let currencyUnit: [String] = ["Rouble", "Euro"]
let euroCurrency = currencyUnit[1]


//Перечисление — это тип данных, содержащий множество альтернативных значений,
//каждое из которых может быть проинициализировано некоторому параметру


enum CurrencyUnit {
 case rouble
 case euro
}

enum CurrencyUnit_new {
 case rouble, euro
}


//После создания нового перечисления одно из его значений (членов перечисления) может быть присвоено параметру (переменной или константе), для этого
//используется специальный синтаксис.
//СИНТАКСИС
//Чтобы инициализировать параметру один из членов перечисления, можно использовать
//два способа:
//• Краткий синтаксис (точка и имя члена перечисления). При этом требуется явно указать
//тип данных параметра.
//let имяПараметра: ИмяПеречисления =.значение
//• Полный синтаксис. При этом тип определяется неявно
//let имяПараметра = ИмяПеречисления.значение
//В дальнейшем для изменения значения переменной, указывающей на член перечисления,
//можно использовать сокращенный синтаксис, так как тип параметра уже определен.
//имяПараметра = .значение
//Имя перечисления выступает в качестве типа данных параметра. Далее доступ к значениям
//происходит уже без указания его имени.
//В листинге 19.5 показаны примеры создания параметров и инициализации им
//членов перечисления CurrencyUnit.


var roubleCurrency: CurrencyUnit = .rouble
var otherCurrency = CurrencyUnit.euro
// поменяем значение одного из параметров на другой член перечисления
//otherCurrency = .rouble

//Ассоциированные параметры

enum AdvancedCurrencyUnit {
    case rouble(сountries: [String], shortName: String)
    case euro(сountries: [String], shortName: String)
}


//ПРИМЕЧАНИЕ При описании ассоциированных параметров не обязательно указывать их
//имена, можно обойтись лишь типами данных.
//enum AdvancedCurrencyUnit {
// case rouble([String], String)
// case euro([String], String)
//}


//Оба члена перечисления содержат одинаковые ассоциированные параметры.
//Параметр countries является массивом, так как валюта может использоваться
//не в одной, а в нескольких странах: например, евро используется на территории
//Европейского союза.
//Теперь, чтобы создать переменную или константу типа AdvancedCurrencyUnit, необходимо указать значения для всех ассоциированных параметров (листинг 19.7)


let euroCurrency_new: AdvancedCurrencyUnit = .euro(сountries: ["German", "France"],
shortName: "EUR")


// страны, использующие доллар
enum DollarCountries {
    case usa
    case canada
    case australia
}


// дополненное перечисление
enum AdvancedCurrencyUnit_new {
    case rouble(сountries: [String], shortName: String)
    case euro(сountries: [String], shortName: String)
    case dollar(nation: DollarCountries, shortName: String)
}
var dollarCurrency: AdvancedCurrencyUnit_new = .dollar( nation: .usa, shortName: "USD" )


//Для параметра nation члена dollar перечисления AdvancedCurrencyUnit используется тип данных DollarCountries. Обратите внимание, что при инициализации значения этого параметра используется сокращенный синтаксис (.usa).
//Это связано с тем, что его тип данных уже задан при определении перечисления
//AdvancedCurrencyUnit.


//вложенные перечисления

//Перечисления могут быть частью других перечислений, то есть могут быть определены в области видимости родительских перечислений.
//Так как перечисление DollarCountries используется исключительно в перечислении AdvancedCurrencyUnit и создано для него, его можно перенести внутрь этого
//перечисления (листинг 19.9).


enum AdvancedCurrencyUnit_new_new {
 enum DollarCountries {
     case usa
     case canada
     case australia
 }
    case rouble(сountries: [String], shortName: String)
    case euro(сountries: [String], shortName: String)
    case dollar(nation: DollarCountries, shortName: String)
}


//Теперь перечисление DollarCountries обладает ограниченной областью видимости и доступно только через родительское перечисление. Можно сказать, что это
//подтип типа, или вложенный тип. Тем не менее при необходимости вы можете
//создать параметр, содержащий значение этого перечисления, и вне перечисления
//AdvancedCurrencyUnit (листинг 19.10).
//Листинг 19.10

let australia: AdvancedCurrencyUnit_new_new.DollarCountries = .australia


//оператор swith для перечислений

//Для анализа и разбора значений перечислений можно использовать оператор
//switch.
//Рассмотрим пример из листинга 19.11, в котором анализируется значение переменной типа AdvancedCurrencyUnit


/*switch dollarCurrency {
    case .rouble:
        print("Рубль")
    case let .euro(countries, shortname):
        print("Евро. Страны: \(countries). Краткое наименование: \(shortname)")
    case .dollar(let nation, let shortname):
        print("Доллар \(nation). Краткое наименование: \(shortname)")
}*/

//В операторе switch описан каждый элемент перечисления AdvancedCurrencyUnit,
//поэтому использовать оператор default не обязательно. Доступ к ассоциированным
//параметрам реализуется связыванием значений: после ключевого слова case и указания значения в скобках объявляются константы, которым будут присвоены ассоциированные с членом перечисления значения. Так как для всех ассоциированных
//параметров создаются константы со связываемым значением, оператор let можно
//ставить сразу после ключевого слова case (это продемонстрировано для члена euro)


//связанные значения членов перечисления

enum Smile: String {
    case joy = ":)"
    case laugh = ":D"
    case sorrow = ":("
    case surprise = "o_O"
}


enum Planet: Int {
 case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune,
pluto = 999
}

let iAmHappy = Smile.joy
//iAmHappy.rawValue // ":)"



//Инициализатор

//При объявлении структуры в ее состав обязательно входит специальный методинициализатор. Более того, вам даже не требуется его объявлять, так как эта
//возможность заложена в Swift изначально. Как мы говорили ранее, при изучении
//фундаментальных типов, инициализаторы всегда имеют имя init. Другими словами, инициализатор — это метод в составе объектного типа (перечисления, или,
//как вы узнаете далее, структуры или класса), имеющий имя init.
//Перечисления имеют всего один инициализатор init(rawValue:). Он позволяет
//передать связанное значение, соответствующее требуемому члену перечисления.
//Таким образом, у нас есть возможность инициализировать параметру конкретный
//член перечисления по связанному с ним значению.
//В листинге 19.15 показан пример использования инициализатора перечисления.


let myPlanet = Planet.init(rawValue: 3) // earth
var anotherPlanet = Planet.init(rawValue: 11) // nil


//Повторю:
// Инициализатор перечисления Planet — это метод init(rawValue:). Ему передается указатель на исходное значение, связанное с искомым членом этого
//перечисления.
//Данный метод не описан в теле перечисления, — он существует там всегда по
//умолчанию и закреплен в исходном коде языка Swift.
//Инициализатор init(rawValue:) возвращает опционал, поэтому если вы укажете
//несуществующее связанное значение, вернется nil.


//Инициализаторы вызываются каждый раз при создании нового экземпляра
//какого-либо перечисления, структуры или класса. Для некоторых конструкций их можно и нужно
//создавать самостоятельно, а для некоторых, вроде перечислений, они существуют по умолчанию.
//Инициализатор проводит процесс инициализации, то есть выполняет установку всех требуемых значений для параметров с непосредственным созданием экземпляра и помещением его в хранилище.
//Инициализатор — это всегда метод с именем init.




//свойства в перечислениях

//Свойство в перечислении — это хранилище, аналогичное переменной или константе, объявленное в пределах перечисления, доступ к которому осуществляется
//через экземпляр перечисления. В Swift существует определенное ограничение для
//свойств в перечислениях: в качестве их значений не могут выступать фиксированные значения-литералы, только замыкания. Такие свойства называются вычисляемыми. При каждом обращении к ним происходит вычисление присвоенного
//замыкания с возвращением получившегося значения.
//Для вычисляемого свойства после имени через двоеточие указывается тип возвращаемого значения и далее без оператора присваивания в фигурных скобках — тело
//замыкающего выражения, генерирующего возвращаемое значение.
//Объявим вычисляемое свойство для разработанного ранее перечисления (листинг 19.16). За основу возьмем перечисление Smile и создадим вычисляемое
//перечисление, которое возвращает связанное с текущим членом перечисления
//значение.


enum Smile_new: String {
 case joy = ":)"
 case laugh = ":D"
 case sorrow = ":("
 case surprise = "o_O"
 // вычисляемое свойство
 var description: String { return self.rawValue }
}
let mySmile: Smile_new = .sorrow
//mySmile.description // ":("

//Вычисляемое свойство должно быть объявлено как переменная (var). В противном случае (если используете оператор let) вы получите сообщение об ошибке.
//С помощью оператора self внутри замыкания вы получаете доступ к текущему
//члену перечисления, при этом его использование не является обязательным. Тем
//не менее данный оператор будет активно использоваться вами при разработке
//приложений. С ним мы познакомимся подробнее уже в ближайших разделах


//методы в перечислениях

//Перечисления могут группировать в себе не только свойства, члены и другие перечисления, но и методы. Ранее мы говорили об инициализаторах init(), которые
//являются встроенными в перечисления методами. Методы — это функции внутри
//324   Глава 19. Перечисления
//перечислений, поэтому их синтаксис и возможности идентичны синтаксису и возможностям изученных ранее функций.
//Вернемся к примеру с перечислением Smile и создадим метод, который выводит на консоль справочную информацию о предназначении перечисления (листинг 19.17).


enum Smile_new_new: String {
 case joy = ":)"
 case laugh = ":D"
 case sorrow = ":("
 case surprise = "o_O"
 var description: String {return self.rawValue}
 func about() {
 print("Перечисление содержит список смайликов")
 }
}
var otherSmile = Smile_new_new.joy
//otherSmile.about()
