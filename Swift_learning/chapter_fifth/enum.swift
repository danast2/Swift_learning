//
//  enum.swift
//  Swift_learning
//
//  Created by Даниил Асташов on 22.10.2024.
//

import Foundation

//Перечисление (enum) — это объектный тип данных, который предоставляет доступ к различным предопределенным значениям. Рассматривайте его как перечень возможных значений, то есть набор констант, значения которых являются
//альтернативами друг другу.
//Рассмотрим хранилище, которое описывает некоторую денежную единицу (листинг 19.1). Для того чтобы решить поставленную задачу с помощью изученных
//ранее типов данных, можно использовать тип String. В этом случае потребуется
//вести учет всех возможных значений для описания денежных единиц

var russianCurrency: String = "Rouble"

//Подобный подход создает проблем больше, чем позволяет решить, поскольку не
//исключает влияния человеческого фактора, из-за которого случайное изменение
//всего лишь одной буквы приведет к тому, что программа не сможет корректно
//обработать поступившее значение. А что делать, если потребуется добавить обработку нового значения денежной единицы?
//Альтернативой этому способу может служить создание коллекции, например
//массива (листинг 19.2). Массив содержит все возможные значения, которые
//доступны в программе. При необходимости происходит получение требуемого
//элемента массива.

let currencyUnit: [String] = ["Rouble", "Euro"]
let euroCurrency = currencyUnit[1]


//Перечисление — это тип данных, содержащий множество альтернативных значений,
//каждое из которых может быть проинициализировано некоторому параметру


enum CurrencyUnit {
 case rouble
 case euro
}

enum CurrencyUnit_new {
 case rouble, euro
}


//После создания нового перечисления одно из его значений (членов перечисления) может быть присвоено параметру (переменной или константе), для этого
//используется специальный синтаксис.
//СИНТАКСИС
//Чтобы инициализировать параметру один из членов перечисления, можно использовать
//два способа:
//• Краткий синтаксис (точка и имя члена перечисления). При этом требуется явно указать
//тип данных параметра.
//let имяПараметра: ИмяПеречисления =.значение
//• Полный синтаксис. При этом тип определяется неявно
//let имяПараметра = ИмяПеречисления.значение
//В дальнейшем для изменения значения переменной, указывающей на член перечисления,
//можно использовать сокращенный синтаксис, так как тип параметра уже определен.
//имяПараметра = .значение
//Имя перечисления выступает в качестве типа данных параметра. Далее доступ к значениям
//происходит уже без указания его имени.
//В листинге 19.5 показаны примеры создания параметров и инициализации им
//членов перечисления CurrencyUnit.


var roubleCurrency: CurrencyUnit = .rouble
var otherCurrency = CurrencyUnit.euro
// поменяем значение одного из параметров на другой член перечисления
//otherCurrency = .rouble

//Ассоциированные параметры

enum AdvancedCurrencyUnit {
    case rouble(сountries: [String], shortName: String)
    case euro(сountries: [String], shortName: String)
}


//ПРИМЕЧАНИЕ При описании ассоциированных параметров не обязательно указывать их
//имена, можно обойтись лишь типами данных.
//enum AdvancedCurrencyUnit {
// case rouble([String], String)
// case euro([String], String)
//}


//Оба члена перечисления содержат одинаковые ассоциированные параметры.
//Параметр countries является массивом, так как валюта может использоваться
//не в одной, а в нескольких странах: например, евро используется на территории
//Европейского союза.
//Теперь, чтобы создать переменную или константу типа AdvancedCurrencyUnit, необходимо указать значения для всех ассоциированных параметров (листинг 19.7)


let euroCurrency_new: AdvancedCurrencyUnit = .euro(сountries: ["German", "France"],
shortName: "EUR")


// страны, использующие доллар
enum DollarCountries {
    case usa
    case canada
    case australia
}


// дополненное перечисление
enum AdvancedCurrencyUnit_new {
    case rouble(сountries: [String], shortName: String)
    case euro(сountries: [String], shortName: String)
    case dollar(nation: DollarCountries, shortName: String)
}
var dollarCurrency: AdvancedCurrencyUnit_new = .dollar( nation: .usa, shortName: "USD" )


//Для параметра nation члена dollar перечисления AdvancedCurrencyUnit используется тип данных DollarCountries. Обратите внимание, что при инициализации значения этого параметра используется сокращенный синтаксис (.usa).
//Это связано с тем, что его тип данных уже задан при определении перечисления
//AdvancedCurrencyUnit.


//вложенные перечисления

//Перечисления могут быть частью других перечислений, то есть могут быть определены в области видимости родительских перечислений.
//Так как перечисление DollarCountries используется исключительно в перечислении AdvancedCurrencyUnit и создано для него, его можно перенести внутрь этого
//перечисления (листинг 19.9).


enum AdvancedCurrencyUnit_new_new {
 enum DollarCountries {
     case usa
     case canada
     case australia
 }
    case rouble(сountries: [String], shortName: String)
    case euro(сountries: [String], shortName: String)
    case dollar(nation: DollarCountries, shortName: String)
}


//Теперь перечисление DollarCountries обладает ограниченной областью видимости и доступно только через родительское перечисление. Можно сказать, что это
//подтип типа, или вложенный тип. Тем не менее при необходимости вы можете
//создать параметр, содержащий значение этого перечисления, и вне перечисления
//AdvancedCurrencyUnit (листинг 19.10).
//Листинг 19.10

let australia: AdvancedCurrencyUnit_new_new.DollarCountries = .australia


//оператор swith для перечислений

//Для анализа и разбора значений перечислений можно использовать оператор
//switch.
//Рассмотрим пример из листинга 19.11, в котором анализируется значение переменной типа AdvancedCurrencyUnit


/*switch dollarCurrency {
    case .rouble:
        print("Рубль")
    case let .euro(countries, shortname):
        print("Евро. Страны: \(countries). Краткое наименование: \(shortname)")
    case .dollar(let nation, let shortname):
        print("Доллар \(nation). Краткое наименование: \(shortname)")
}*/

//В операторе switch описан каждый элемент перечисления AdvancedCurrencyUnit,
//поэтому использовать оператор default не обязательно. Доступ к ассоциированным
//параметрам реализуется связыванием значений: после ключевого слова case и указания значения в скобках объявляются константы, которым будут присвоены ассоциированные с членом перечисления значения. Так как для всех ассоциированных
//параметров создаются константы со связываемым значением, оператор let можно
//ставить сразу после ключевого слова case (это продемонстрировано для члена euro)


//связанные значения членов перечисления

enum Smile: String {
    case joy = ":)"
    case laugh = ":D"
    case sorrow = ":("
    case surprise = "o_O"
}


enum Planet: Int {
 case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune,
pluto = 999
}

let iAmHappy = Smile.joy
//iAmHappy.rawValue // ":)"



//Инициализатор

//При объявлении структуры в ее состав обязательно входит специальный методинициализатор. Более того, вам даже не требуется его объявлять, так как эта
//возможность заложена в Swift изначально. Как мы говорили ранее, при изучении
//фундаментальных типов, инициализаторы всегда имеют имя init. Другими словами, инициализатор — это метод в составе объектного типа (перечисления, или,
//как вы узнаете далее, структуры или класса), имеющий имя init.
//Перечисления имеют всего один инициализатор init(rawValue:). Он позволяет
//передать связанное значение, соответствующее требуемому члену перечисления.
//Таким образом, у нас есть возможность инициализировать параметру конкретный
//член перечисления по связанному с ним значению.
//В листинге 19.15 показан пример использования инициализатора перечисления.


let myPlanet = Planet.init(rawValue: 3) // earth
var anotherPlanet = Planet.init(rawValue: 11) // nil


//Повторю:
// Инициализатор перечисления Planet — это метод init(rawValue:). Ему передается указатель на исходное значение, связанное с искомым членом этого
//перечисления.
//Данный метод не описан в теле перечисления, — он существует там всегда по
//умолчанию и закреплен в исходном коде языка Swift.
//Инициализатор init(rawValue:) возвращает опционал, поэтому если вы укажете
//несуществующее связанное значение, вернется nil.


//Инициализаторы вызываются каждый раз при создании нового экземпляра
//какого-либо перечисления, структуры или класса. Для некоторых конструкций их можно и нужно
//создавать самостоятельно, а для некоторых, вроде перечислений, они существуют по умолчанию.
//Инициализатор проводит процесс инициализации, то есть выполняет установку всех требуемых значений для параметров с непосредственным созданием экземпляра и помещением его в хранилище.
//Инициализатор — это всегда метод с именем init.




//свойства в перечислениях

//Свойство в перечислении — это хранилище, аналогичное переменной или константе, объявленное в пределах перечисления, доступ к которому осуществляется
//через экземпляр перечисления. В Swift существует определенное ограничение для
//свойств в перечислениях: в качестве их значений не могут выступать фиксированные значения-литералы, только замыкания. Такие свойства называются вычисляемыми. При каждом обращении к ним происходит вычисление присвоенного
//замыкания с возвращением получившегося значения.
//Для вычисляемого свойства после имени через двоеточие указывается тип возвращаемого значения и далее без оператора присваивания в фигурных скобках — тело
//замыкающего выражения, генерирующего возвращаемое значение.
//Объявим вычисляемое свойство для разработанного ранее перечисления (листинг 19.16). За основу возьмем перечисление Smile и создадим вычисляемое
//перечисление, которое возвращает связанное с текущим членом перечисления
//значение.


enum Smile_new: String {
 case joy = ":)"
 case laugh = ":D"
 case sorrow = ":("
 case surprise = "o_O"
 // вычисляемое свойство
 var description: String { return self.rawValue }
}
let mySmile: Smile_new = .sorrow
//mySmile.description // ":("

//Вычисляемое свойство должно быть объявлено как переменная (var). В противном случае (если используете оператор let) вы получите сообщение об ошибке.
//С помощью оператора self внутри замыкания вы получаете доступ к текущему
//члену перечисления, при этом его использование не является обязательным. Тем
//не менее данный оператор будет активно использоваться вами при разработке
//приложений. С ним мы познакомимся подробнее уже в ближайших разделах


//методы в перечислениях

//Перечисления могут группировать в себе не только свойства, члены и другие перечисления, но и методы. Ранее мы говорили об инициализаторах init(), которые
//являются встроенными в перечисления методами. Методы — это функции внутри
//324   Глава 19. Перечисления
//перечислений, поэтому их синтаксис и возможности идентичны синтаксису и возможностям изученных ранее функций.
//Вернемся к примеру с перечислением Smile и создадим метод, который выводит на консоль справочную информацию о предназначении перечисления (листинг 19.17).


enum Smile_new_new: String {
 case joy = ":)"
 case laugh = ":D"
 case sorrow = ":("
 case surprise = "o_O"
 var description: String {return self.rawValue}
 func about() {
 print("Перечисление содержит список смайликов")
 }
}
var otherSmile = Smile_new_new.joy
//otherSmile.about()


//оператор self

//Для организации доступа к текущему значению перечисления внутри этого
//перечисления используется оператор self (в одном из предыдущих листингов
//мы уже использовали его). Данный оператор возвращает указатель на текущий
//конкретный член перечисления, инициализированный параметру.
//Рассмотрим пример.
//Требуется написать два метода: один будет возвращать сам член перечисления,
//а второй — его связанное значение. Используем для этого уже знакомое перечисление Smile (листинг 19.18).


enum Smile_fresh: String {
     case joy = ":)"
     case laugh = ":D"
     case sorrow = ":("
     case surprise = "o_O"
    var description: String { return self.rawValue }
 func about() {
     print("Перечисление содержит список смайликов")
 }
 func descriptionValue() -> Smile_fresh {
     return self
 }
 func descriptionRawValue() -> String {
 // использование self перед rawValue не является обязательным
     return rawValue
 }
}
var otherSmile_new = Smile_fresh.joy
//otherSmile.descriptionValue() // joy
//otherSmile.descriptionRawValue() // ":)"



//рекурсивные перечисления

//Перечисления отлично справляются с моделированием ситуации, когда есть
//всего несколько вариантов ее развития. Но вы можете использовать их не только
//для того, чтобы хранить некоторые связанные и ассоциированные значения. Вы
//можете пойти дальше и наделить перечисление функциональностью анализа
//собственного значения и вычисления на его основе выражений.
//Возьмем, к примеру, простейшие арифметические операции: сложение, вычитание,
//умножение и деление. Все они заранее известны, поэтому могут быть помещены
//в перечисление в качестве его членов (листинг 19.19). Для простоты оставим
//только две операции: сложение и вычитание


enum ArithmeticExpression {
 // операция сложения
 case addition(Int, Int)
 // операция вычитания
 case substraction(Int, Int)
}
let expr = ArithmeticExpression.addition(10, 14)

//Каждый из членов перечисления соответствует операции с двумя операндами.
//В связи с этим они имеют по два ассоциированных параметра.
//В результате выполнения кода в переменной expr будет храниться член перечисления ArithmeticExpression, определяющий арифметическую операцию сложения.
//Объявленное перечисление не несет какой-либо функциональной нагрузки в вашем приложении. Но вы можете создать в его пределах метод, который определяет
//наименование члена и возвращает результат данной операции (листинг 19.20).


enum ArithmeticExpression_new {
     case addition(Int, Int)
     case substraction(Int, Int)
 func evaluate() -> Int {
     switch self {
     case .addition(let left, let right):
         return left + right
     case .substraction(let left, let right):
         return left - right
     }
 }
}
var expr_new = ArithmeticExpression.addition(10, 14)
//expr_new.evaluate() // 24


//При вызове метода evaluate() происходит поиск определенного в данном экземпляре члена перечисления. Для этого используются операторы switch и self.
//Далее, после того как член определен, путем связывания значений возвращается
//результат требуемой арифметической операции.
//Данный способ работает просто замечательно, но имеет серьезное ограничение: он
//способен моделировать только одноуровневые арифметические выражения: 1 + 5,
//6 + 19 и т. д. В ситуации, когда выражение имеет вложенные выражения: 1 + (5 — 7),
//6 — 5 + 4 и т. д., придется вычислять каждое отдельное действие с использованием
//собственного экземпляра типа ArithmeticExpression.
//Для решения этой проблемы необходимо доработать перечисление
//ArithmeticExpression таким образом, чтобы оно давало возможность складывать
//не только значения типа Int, но и значения типа ArithmeticExpression.
//Получается, что перечисление, описывающее выражение, должно давать возможность выполнять операции само с собой. Данный механизм реализуется в рекурсивном перечислении. Для того чтобы разрешить членам перечисления обращаться
//к этому перечислению, используется ключевое слово indirect, которое ставится:
//либо перед оператором enum — в этом случае каждый член перечисления может
//обратиться к данному перечислению;
// либо перед оператором case того члена, в котором необходимо обратиться
//к перечислению.
//Если в качестве ассоциированных параметров перечисления указывать значения
//типа самого перечисления ArithmeticExpression, то возникает вопрос: а где же
//хранить числа, над которыми совершаются операции? Такие числа также необходимо хранить в самом перечислении, в его отдельном члене.
//Рассмотрим пример из листинга 19.21. В данном примере вычисляется значение
//выражения 20 + 10 — 34.


enum ArithmeticExpression_n {
    case number(Int)
    indirect case addition(ArithmeticExpression_n, ArithmeticExpression_n)
    indirect case subtraction(ArithmeticExpression_n, ArithmeticExpression_n)
    func evaluate(_ expression: ArithmeticExpression_n? = nil) -> Int {
        switch expression ?? self {
        case let .number(value):
            return value
        case let .addition(valueLeft, valueRight):
            return evaluate(valueLeft) + evaluate(valueRight)
        case .subtraction(let valueLeft, let valueRight):
            return evaluate(valueLeft) - evaluate(valueRight)
        }
    }

}

let hardExpr = ArithmeticExpression_n.addition( .number(20), .subtraction( .number(10), .number(34)))
let result_n = hardExpr.evaluate() // -4
