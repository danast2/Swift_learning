//
//  protocol.swift
//  Swift_learning
//
//  Created by Даниил Асташов on 25.10.2024.
//

import Foundation


//Глава 30. Протоколы
//В процессе изучения основ разработки на языке Swift мы уже неоднократно обращались к понятию протокола. Вам уже хорошо известны Equatable, Comparable
//и многие другие протоколы, благодаря которым типы данных делятся на категории. Эта и несколько следующих глав продолжат знакомить вас с этим элементом
//языка, и вы научитесь самостоятельно реализовывать и использовать их.
//30.1. Понятие протокола
//В самом простом случае протокол — это перечень требований, которым должен
//удовлетворять тип данных, соответствующий ему. В более сложных случаях протокол также может содержать не просто требования наличия свойств и методов,
//но и их конкретную реализацию (об этом будет подробно рассказано в главах про
//расширения и протокол-ориентированное программирование). Если у вас есть
//опыт разработки на других языках, то, вполне вероятно, вы встречались с понятием интерфейса, или контракта, которые являются синонимами протокола


//ПРИМЕЧАНИЕ Если к типу данных применяется протокол, это означает, что:
//• тип данных подписан на протокол,
//или
//• тип данных реализует требования протокола,
//или
//• тип данных принимает протокол к реализации,
//или
//• тип данных соответствует протоколу.
//В протоколе может содержаться перечень свойств, методов и сабскриптов, которые
//должны быть реализованы в объектном типе, принимающем его к реализации.
//Другими словами, протоколы содержат требования к наличию определенных
//элементов внутри типа данных.
//Рассмотрим синтаксис объявления протоколов.
//СИНТАКСИС
//protocol ИмяПротокола {
// // тело протокола
//}


//Для объявления нового протокола используется ключевое слово protocol, после которого
//указывается его имя (в верхнем верблюжьем регистре).
//Любой объектный тип данных может быть подписан на протокол, неважно, используете вы
//перечисления (enum), структуры (struct) или класс (class). Для того чтобы принять протокол
//к исполнению, необходимо написать его имя через двоеточие сразу после имени объектного
//типа данных:
//struct ИмяПринимающегоТипа: ИмяПротокола {
// // тело структуры
//}
//После подписки на протокол тип данных обязан выполнить все его требования, то есть
//реализовать свойства, методы и сабскрипты, описанные в протоколе. При этом тип может
//быть подписан на произвольное количество протоколов.
//enum ИмяПринимающегоТипа: ИмяПротокола, ИмяДругогоПротокола {
// // тело перечисления
//}
//Если класс не просто принимает протоколы, но и наследует другой класс, то имя родительского класса необходимо указать первым, а за ним через запятую — список протоколов:
//class ИмяПринимающегоКласса: ИмяСуперКласса, ИмяПротокола, ИмяДругогоПротокола {
// // тело класса
//}


//30.2. Требуемые свойства
//В протоколе может содержаться требование реализации одного или нескольких
//свойств (в том числе свойств типа, указываемых с помощью ключевого слова
//static). При этом для каждого свойства в протоколе указывается:
// название;
// тип данных;
// требования доступности и изменяемости.
//В листинге 30.1 приведен пример объявления протокола.
//Листинг 30.1
//protocol SomeProtocol {
// var mustBeSettable: Int { get set }
// var doesNotNeedToBeSettable: Int { get }
//}
//Протокол SomeProtocol имеет требования реализации двух свойств. Таким образом, если тип данных подпишется на протокол SomeProtocol, то в нем потребуется
//реализовать данные свойства, при этом:
// Первое свойство должно иметь название mustBeSettable, а второе —
//doesNotNeedToBeSettable


//Тип данных обоих свойств — Int.
// Свойство mustBeSettable должно быть доступно как для чтения, так и для изменения, то есть в нем должны быть геттер и сеттер.
// Свойство doesNotNeedToBeSettable, в свою очередь, должно иметь как минимум геттер.
//Требования доступности и изменяемости определяются с помощью конструкций
//{ get } и { get set }. В первом случае у свойства должен быть как минимум геттер,
//а во втором — и геттер и сеттер. В случае, если свойству определено требование { get
//set }, то оно не может быть вычисляемым «только для чтения» или константой.
//Протокол определяет минимальные требования к типу, то есть тип данных обязан
//реализовать все, что описано в протоколе, но он может не ограничиваться этим
//набором. Так, для свойства doesNotNeedToBeSettable из предыдущего листинга
//может быть реализован не только геттер, но и сеттер (в протоколе содержится
//требование реализации геттера).
//В листинге 30.2 показан пример реализации типом данных SomeStruct требований
//протокола SomeProtocol.
//Листинг 30.2
//struct SomeStruct: SomeProtocol {
// var mustBeSettable: Int
// let doesNotNeedToBeSettable: Int
// // дополнительный метод, не описанный в протоколе
// func getSum() -> Int {
// return self.mustBeSettable + self.doesNotNeedToBeSettable
// }
//}
//Тип данных SomeStruct полностью соответствует описанному ранее протоколу
//SomeProtocol, но при этом содержит дополнительный метод getSum(), который
//возвращает сумму свойств.
//Для указания в протоколе требования к реализации свойства типа необходимо
//использовать модификатор static (листинг 30.3).
//Листинг 30.3
//protocol AnotherProtocol {
// static var someTypeProperty: Int { get }
//}


//Если тип данных подписывается на протокол AnotherProtocol, то в нем обязательно должно быть реализовано свойство типа someTypeProperty (листинг 30.4).
//Листинг 30.4
//struct AnotherStruct: SomeProtocol, AnotherProtocol {
// var mustBeSettable: Int
// let doesNotNeedToBeSettable: Int
// static var someTypeProperty: Int = 3
// func getSum() -> Int {
// return self.mustBeSettable
// + self.doesNotNeedToBeSettable
// + AnotherStruct.someTypeProperty
// }
//}
//Структура AnotherStruct принимает к реализации два протокола: SomeProtocol
//и AnotherProtocol. Это значит, что в ней должны быть реализованы все элементы
//обоих протоколов.


//30.3. Требуемые методы
//Помимо свойств, протокол может содержать требования к реализации одного
//или нескольких методов. Для требования реализации метода типа необходимо
//использовать модификатор static, а для изменяющего метода — mutating.
//ПРИМЕЧАНИЕ Если вы указали ключевое слово mutating перед требованием метода, то
//указывать его при реализации метода в классе уже не нужно. Данное ключевое слово требуется
//только при реализации структуры.
//В листинге 30.5 показан пример объявления протокола, содержащего требование
//к реализации методов.
//Листинг 30.5
protocol RandomNumberGenerator {
     var randomCollection: [Int] { get set }
     func getRandomNumber() -> Int
     mutating func setNewRandomCollection(newValue: [Int])
}
//Протокол RandomNumberGenerator содержит требования реализации свойства
//randomCollection и двух методов: getRandomNumber() и setNewRandomCollection
//(newValue:).
//При реализации методов в объектном типе необходимо в точности соблюдать все
//требования протокола: имя метода, наличие или отсутствие входных аргументов,
//тип возвращаемого значения и модификаторы.
//В листинге 30.6 показан пример создания структуры и класса, принимающих
//протокол RandomNumberGenerator.
//Листинг 30.6
struct RandomGenerator: RandomNumberGenerator {
     var randomCollection: [Int] = [1,2,3,4,5]
     func getRandomNumber() -> Int {
         if let randomElement = randomCollection.randomElement() {
                     return randomElement
                 }
        return 0 // Возвращаем значение по умолчанию, если массив пуст
 }
mutating func setNewRandomCollection(newValue: [Int]) {
    self.randomCollection = newValue
 }
}
class RandomGeneratorClass: RandomNumberGenerator {
     var randomCollection: [Int] = [1,2,3,4,5]
     func getRandomNumber() -> Int {
     if let randomElement = randomCollection.randomElement() {
         return randomElement
     }
    return 0
 }
 // не используется модификатор mutating
 func setNewRandomCollection(newValue: [Int]) {
     self.randomCollection = newValue
 }
}
