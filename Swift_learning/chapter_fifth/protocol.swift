//
//  protocol.swift
//  Swift_learning
//
//  Created by Даниил Асташов on 25.10.2024.
//

import Foundation


//Глава 30. Протоколы
//В процессе изучения основ разработки на языке Swift мы уже неоднократно обращались к понятию протокола. Вам уже хорошо известны Equatable, Comparable
//и многие другие протоколы, благодаря которым типы данных делятся на категории. Эта и несколько следующих глав продолжат знакомить вас с этим элементом
//языка, и вы научитесь самостоятельно реализовывать и использовать их.
//30.1. Понятие протокола
//В самом простом случае протокол — это перечень требований, которым должен
//удовлетворять тип данных, соответствующий ему. В более сложных случаях протокол также может содержать не просто требования наличия свойств и методов,
//но и их конкретную реализацию (об этом будет подробно рассказано в главах про
//расширения и протокол-ориентированное программирование). Если у вас есть
//опыт разработки на других языках, то, вполне вероятно, вы встречались с понятием интерфейса, или контракта, которые являются синонимами протокола


//ПРИМЕЧАНИЕ Если к типу данных применяется протокол, это означает, что:
//• тип данных подписан на протокол,
//или
//• тип данных реализует требования протокола,
//или
//• тип данных принимает протокол к реализации,
//или
//• тип данных соответствует протоколу.
//В протоколе может содержаться перечень свойств, методов и сабскриптов, которые
//должны быть реализованы в объектном типе, принимающем его к реализации.
//Другими словами, протоколы содержат требования к наличию определенных
//элементов внутри типа данных.
//Рассмотрим синтаксис объявления протоколов.
//СИНТАКСИС
//protocol ИмяПротокола {
// // тело протокола
//}


//Для объявления нового протокола используется ключевое слово protocol, после которого
//указывается его имя (в верхнем верблюжьем регистре).
//Любой объектный тип данных может быть подписан на протокол, неважно, используете вы
//перечисления (enum), структуры (struct) или класс (class). Для того чтобы принять протокол
//к исполнению, необходимо написать его имя через двоеточие сразу после имени объектного
//типа данных:
//struct ИмяПринимающегоТипа: ИмяПротокола {
// // тело структуры
//}
//После подписки на протокол тип данных обязан выполнить все его требования, то есть
//реализовать свойства, методы и сабскрипты, описанные в протоколе. При этом тип может
//быть подписан на произвольное количество протоколов.
//enum ИмяПринимающегоТипа: ИмяПротокола, ИмяДругогоПротокола {
// // тело перечисления
//}
//Если класс не просто принимает протоколы, но и наследует другой класс, то имя родительского класса необходимо указать первым, а за ним через запятую — список протоколов:
//class ИмяПринимающегоКласса: ИмяСуперКласса, ИмяПротокола, ИмяДругогоПротокола {
// // тело класса
//}


//30.2. Требуемые свойства
//В протоколе может содержаться требование реализации одного или нескольких
//свойств (в том числе свойств типа, указываемых с помощью ключевого слова
//static). При этом для каждого свойства в протоколе указывается:
// название;
// тип данных;
// требования доступности и изменяемости.
//В листинге 30.1 приведен пример объявления протокола.
//Листинг 30.1
//protocol SomeProtocol {
// var mustBeSettable: Int { get set }
// var doesNotNeedToBeSettable: Int { get }
//}
//Протокол SomeProtocol имеет требования реализации двух свойств. Таким образом, если тип данных подпишется на протокол SomeProtocol, то в нем потребуется
//реализовать данные свойства, при этом:
// Первое свойство должно иметь название mustBeSettable, а второе —
//doesNotNeedToBeSettable


//Тип данных обоих свойств — Int.
// Свойство mustBeSettable должно быть доступно как для чтения, так и для изменения, то есть в нем должны быть геттер и сеттер.
// Свойство doesNotNeedToBeSettable, в свою очередь, должно иметь как минимум геттер.
//Требования доступности и изменяемости определяются с помощью конструкций
//{ get } и { get set }. В первом случае у свойства должен быть как минимум геттер,
//а во втором — и геттер и сеттер. В случае, если свойству определено требование { get
//set }, то оно не может быть вычисляемым «только для чтения» или константой.
//Протокол определяет минимальные требования к типу, то есть тип данных обязан
//реализовать все, что описано в протоколе, но он может не ограничиваться этим
//набором. Так, для свойства doesNotNeedToBeSettable из предыдущего листинга
//может быть реализован не только геттер, но и сеттер (в протоколе содержится
//требование реализации геттера).
//В листинге 30.2 показан пример реализации типом данных SomeStruct требований
//протокола SomeProtocol.
//Листинг 30.2
//struct SomeStruct: SomeProtocol {
// var mustBeSettable: Int
// let doesNotNeedToBeSettable: Int
// // дополнительный метод, не описанный в протоколе
// func getSum() -> Int {
// return self.mustBeSettable + self.doesNotNeedToBeSettable
// }
//}
//Тип данных SomeStruct полностью соответствует описанному ранее протоколу
//SomeProtocol, но при этом содержит дополнительный метод getSum(), который
//возвращает сумму свойств.
//Для указания в протоколе требования к реализации свойства типа необходимо
//использовать модификатор static (листинг 30.3).
//Листинг 30.3
//protocol AnotherProtocol {
// static var someTypeProperty: Int { get }
//}


//Если тип данных подписывается на протокол AnotherProtocol, то в нем обязательно должно быть реализовано свойство типа someTypeProperty (листинг 30.4).
//Листинг 30.4
//struct AnotherStruct: SomeProtocol, AnotherProtocol {
// var mustBeSettable: Int
// let doesNotNeedToBeSettable: Int
// static var someTypeProperty: Int = 3
// func getSum() -> Int {
// return self.mustBeSettable
// + self.doesNotNeedToBeSettable
// + AnotherStruct.someTypeProperty
// }
//}
//Структура AnotherStruct принимает к реализации два протокола: SomeProtocol
//и AnotherProtocol. Это значит, что в ней должны быть реализованы все элементы
//обоих протоколов.


//30.3. Требуемые методы
//Помимо свойств, протокол может содержать требования к реализации одного
//или нескольких методов. Для требования реализации метода типа необходимо
//использовать модификатор static, а для изменяющего метода — mutating.
//ПРИМЕЧАНИЕ Если вы указали ключевое слово mutating перед требованием метода, то
//указывать его при реализации метода в классе уже не нужно. Данное ключевое слово требуется
//только при реализации структуры.
//В листинге 30.5 показан пример объявления протокола, содержащего требование
//к реализации методов.
//Листинг 30.5
protocol RandomNumberGenerator {
     var randomCollection: [Int] { get set }
     func getRandomNumber() -> Int
     mutating func setNewRandomCollection(newValue: [Int])
}
//Протокол RandomNumberGenerator содержит требования реализации свойства
//randomCollection и двух методов: getRandomNumber() и setNewRandomCollection
//(newValue:).
//При реализации методов в объектном типе необходимо в точности соблюдать все
//требования протокола: имя метода, наличие или отсутствие входных аргументов,
//тип возвращаемого значения и модификаторы.
//В листинге 30.6 показан пример создания структуры и класса, принимающих
//протокол RandomNumberGenerator.
//Листинг 30.6
struct RandomGenerator: RandomNumberGenerator {
     var randomCollection: [Int] = [1,2,3,4,5]
     func getRandomNumber() -> Int {
         if let randomElement = randomCollection.randomElement() {
                     return randomElement
                 }
        return 0 // Возвращаем значение по умолчанию, если массив пуст
 }
mutating func setNewRandomCollection(newValue: [Int]) {
    self.randomCollection = newValue
 }
}
class RandomGeneratorClass: RandomNumberGenerator {
     var randomCollection: [Int] = [1,2,3,4,5]
     func getRandomNumber() -> Int {
     if let randomElement = randomCollection.randomElement() {
         return randomElement
     }
    return 0
 }
 // не используется модификатор mutating
 func setNewRandomCollection(newValue: [Int]) {
     self.randomCollection = newValue
 }
}


//30.4. Требуемые инициализаторы
//Протокол может предъявлять требования к реализации инициализаторов. При
//этом в классах можно реализовать назначенные (designated) или вспомогательные (convenience) инициализаторы. В любом случае перед объявлением
//инициализатора в классе необходимо указывать модификатор required. Это
//гарантирует, что вы реализуете указанный инициализатор во всех подклассах
//данного класса.
//ПРИМЕЧАНИЕ Нет нужды обозначать реализацию инициализаторов протокола модификатором required в классах, которые имеют модификатор final.
//Реализуем протокол, содержащий требования к реализации инициализатора,
//и класс, выполняющий требования данного протокола (листинг 30.7).


protocol Named {
    init(name: String)
}
class Person_b: Named {
     var name: String
     required init(name: String) {
     self.name = name
     }
}


//30.5. Протокол в качестве типа данных
//Протокол может выступать в качестве типа данных, то есть в определенных случаях вы можете писать не имя конкретного типа, а имя протокола, которому должно
//соответствовать значение. Рассмотрим несколько случаев.
//Протокол, указывающий на множество типов
//Протокол может выступать в качестве указателя на множество типов данных. С его
//помощью определяется требование к значению: оно должно иметь тип данных,
//соответствующий указанному протоколу. С этим подходом мы уже неоднократно
//встречались в процессе изучения материала книги, когда название протокола (например, Hashable) указывало на целую категорию типов.
//Рассмотрим пример из листинга 30.8.
//Листинг 30.8
//func getHash<T: Hashable>(of value: T) -> Int {
// return value.hashValue
//}
//ПРИМЕЧАНИЕ Приведенный в листинге код, возможно, покажется вам сложным, так как
//в нем используются не изученные ранее конструкции. Такой прием называется универсальным
//шаблоном (generic) и будет подробно рассмотрен в следующих главах.
//Функция getHash может принять любое значение типа T, где тип T должен соответствовать протоколу Hashable. Таким образом, данный протокол указывает на
//целое множество типов данных. Так, вы можете передать в нее значение любого
//хешируемого типа и получить значение свойства hashValue (листинг 30.9).
//Листинг 30.9
//getHash(of: 5)
//getHash(of: "Swift")


//Протокол и операторы as? и as!
//Операторы as? и as! уже знакомы вам — мы рассматривали их, когда изучали
//классы. Напомню, что эти операторы производят попытку приведения указанного
//до оператора значения к указанному после оператора типу данных.
//Рассмотрим следующий пример: предположим, что у нас есть коллекция, которая
//может хранить элементы произвольных типов данных. При этом вы помещаете
//в нее значения как фундаментальных, так и собственных типов (листинг 30.10).


protocol HasValue {
 var value: Int { get set }
}
class ClassWithValue: HasValue {
     var value: Int
     init(value: Int) {
     self.value = value
 }
}
struct StructWithValue: HasValue {
    var value: Int
}
// коллекция элементов
let objects: [Any] = [
     2,
     StructWithValue(value: 3),
     true,
     ClassWithValue(value: 6),
     "Usov"
]


//Типы данных StructWithValue и ClassWithValue подписаны на протокол HasValue.
//Значения этих типов вперемешку со значениями других типов помещены в коллекцию objects.
//Предположим, что теперь вам необходимо перебрать все элементы коллекции,
//выбрать из них те, что соответствуют протоколу HasValue, и вывести для них на
//консоль значение свойства value. Эту задачу позволит нам выполнить оператор as?


//for object in objects {
// if let elementWithValue = object as? HasValue {
//     print("Значение \(elementWithValue.value)")
// }
//}


//Протокол и оператор is
//Вы можете использовать протоколы совместно с оператором is для проверки
//соответствия типа данных значения этому протоколу. В листинге 30.12 приведен
//пример, использующий коллекцию элементов различных типов.
//412   Глава 30. Протоколы
//Листинг 30.12
//for object in objects {
// print(object is HasValue)
//}
//Консоль
//false
//true
//false
//true
//false
//Если проверяемый элемент соответствует протоколу, то при проверке соответствия
//возвращается значение true, и false — в ином случае.


//30.6. Наследование протоколов
//Протокол может наследовать один или более других протоколов. При этом в него
//могут быть добавлены новые требования поверх наследуемых — тогда тип, принявший протокол к реализации, будет вынужден выполнить требования всех протоколов в иерархии. При наследовании протоколов используется тот же синтаксис,
//что и при наследовании классов.
//Работа с наследуемыми протоколами показана в листинге 30.13.
//Листинг 30.13
import Foundation
protocol GeometricFigureWithXAxis {
    var x: Int { get set }
}
protocol GeometricFigureWithYAxis {
    var y: Int { get set }
}
protocol GeometricFigureTwoAxis: GeometricFigureWithXAxis,
GeometricFigureWithYAxis {
 var distanceFromCenter: Float { get }
}
struct Figure2D: GeometricFigureTwoAxis {
     var x: Int = 0
     var y: Int = 0
     var distanceFromCenter: Float {
     let xPow = pow(Double(self.x), 2)
     let yPow = pow(Double(self.y), 2)
     let length = sqrt(xPow + yPow)
     return Float(length)
     }
}


//Протоколы GeometricFigureWithXAxis и GeometricFigureWithYAxis определяют
//требование на наличие свойства, указывающего на координату объекта на определенной оси. В свою очередь, протокол GeometricFigureTwoAxis объединяет
//требования двух вышеназванных протоколов, а также вводит дополнительное
//свойство. В результате структура Figure2D, принимающая к реализации протокол GeometricFigureTwoAxis, должна иметь все свойства, описанные во всех трех
//протоколах.


//30.7. Классовые протоколы
//Вы можете ограничить применение протокола исключительно на классы, запретив
//его использование для структур и перечислений. Для этого после имени протокола
//через двоеточие необходимо указать ключевое слово class, после которого могут
//быть определены родительские протоколы.
//В листинге 30.14 приведен пример создания классового протокола SubProtocol.
//Листинг 30.14
//protocol SuperProtocol { }
//protocol SubProtocol: class, SuperProtocol { }
//class ClassWithProtocol: SubProtocol { } // корректно
//struct StructWithProtocol: SubProtocol { } // ошибка


//30.8. Композиция протоколов
//В случаях, когда протокол выступает в качестве указателя на множество типов
//данных, бывает удобнее требовать, чтобы тип данных используемого значения
//соответствовал не одному, а нескольким протоколам. В этом случае можно пойти
//двумя путями:
//1. Создать протокол, который подписывается на два родительских протокола,
//и использовать его в качестве указателя на тип данных.
//2. Использовать композицию протоколов, то есть комбинацию нескольких протоколов.
//СИНТАКСИС
//Протокол1 & Протокол2 ...
//Для композиции необходимо указать имена входящих в нее протоколов, разделив их оператором & (амперсанд).
//414   Глава 30. Протоколы
//В листинге 30.15 приведен пример, в котором два протокола комбинируются
//в единое требование.
//Листинг 30.15
//protocol Named {
// var name: String { get }
//}
//protocol Aged {
// var age: Int { get }
//}
//struct Person: Named, Aged {
// var name: String
// var age: Int
//}
//func wishHappyBirthday(celebrator: Named & Aged) {
// print("С Днем рождения, \(celebrator.name)! Тебе уже \(celebrator.age)!")
//}
//let birthdayPerson = Person(name: "Джон Уик", age: 46)
//wishHappyBirthday(celebrator: birthdayPerson)
//Консоль
//С Днем рождения, Джон Уик! Тебе уже 46!
//В данном примере объявляются два протокола: Named и Aged. Созданная структура
//принимает оба протокола и в полной мере выполняет их требования.
//Входным аргументом функции wishHappyBirthday(celebrator:) должно быть
//значение, которое удовлетворяет обоим протоколам. Таким значением является
//экземпляр структуры Person, который мы и передаем.
