//
//  string.swift
//  Swift_learning
//
//  Created by Даниил Асташов on 10.10.2024.
//

import Foundation

/*На концептуальном уровне строка в Swift — это сохраненная в памяти последовательность символов, представленная как коллекция. Да, именно коллекция!
 String соответствует требованиям протокола Collection и является коллекцией,
 подобной массивам, множествам и словарям, но со своими особенностями*/


/*Во-первых, так как String — коллекция, то вам доступно большинство возможностей, характерных для коллекций. К примеру, можно получить количество всех
 элементов с помощью свойства count или for in*/
let str_n = "Hello!"
//str_n.count // 6

/*Каждый элемент строкового значения типа String представляет собой значение
 типа Character, то есть отдельный символ, который может быть представлен с помощью юникод-скаляра (конструкции \u{}, включающей кодовую точку).*/

/*В-третьих, значение типа String — это упорядоченная коллекция. Элементы
 в ней находятся именно в том порядке, какой определил разработчик при инициализации значения.
 На данный момент можно сказать, что строка (значение типа String) — это упорядоченная коллекция, каждый элемент которой представляет собой значение
 типа Character*/

//в swift так не работает
//str[2] // error: 'subscript' is unavailable: cannot subscript String with an Int

//9.2. Графем-кластеры
let char: Character = "\u{E9}"
//char // "é"

let anotherChar: Character = "\u{65}\u{301}"
//anotherChar // "é"

/*И так как тип данных этих параметров — Character, ясно, что в обоих случаях
 для Swift значение состоит из одного символа. Если провести сравнение значений этих переменных, то в результате будет возвращено true, что говорит об их
 идентичности*/
//char == anotherChar // true

/*Дело в том, что в константе anotherChar содержится комбинированный символ, состоящий из двух кодовых точек и, по сути,
 являющийся одним полноценным.
 Существование таких комбинированных символов становится возможным благодаря специальным символам, модифицирующим предыдущий по отношению
 к ним символ (как знак ударения в листинге выше, он изменяет отображение
 латинской буквы e).
 В связи с этим при работе со строковыми значениями не всегда корректным будет
 говорить именно о символах, так как мы видели ранее, что символ по своей сути
 сам может состоять из нескольких символов. В этом случае лучше обратиться
 к понятию графем-кластера.
 Графем-кластер — это совокупность юникод-скаляров (или кодовых точек), при
 визуальном представлении выглядящих как один символ. Графем-кластер может
 состоять из одного или двух юникод-скаляров. Таким образом, в будущем, говоря
 о значении типа Character, мы будем подразумевать не просто отдельный символ,
 а графем-кластер.
 Графем-кластеры могут определять не только буквы алфавита, но и эмодзи. В листинге 9.6 приведен пример комбинирования символов «Thumbs up sign» (кодовая
 точка — 1f44d) и «Emoji Modifier Fitzpatrick Type-4» (кодовая точка — 1f3fd)
 в единый графем-кластер для вывода нового эмодзи (палец вверх со средиземноморским цветом кожи).*/

let thumbsUp = "\u{1f44d}" //
let blackSkin = "\u{1f3fd}" //
let combine = "\u{1f44d}\u{1f3fd}" //

//Вернемся к примеру с символом é. В листинге 9.7 создаются две строки, содержащие данный символ, первая из них содержит непосредственно сам символ é,
//а вторая — комбинацию из латинской e и знака ударения.
//Листинг 9.7
let cafeSimple = "caf\u{E9}" // "café"
let cafeCombine = "cafe\u{301}" // "café"
//cafeSimple.count // 4
//cafeCombine.count // 4

/*Как видно из данного примера, несмотря на то что в переменной cafeCombine
 пять символов, свойство count для обоих вариантов возвращает значение 4. Это
 связано с тем, что для Swift строка — это коллекция символов, каждый из которых
 является графем-кластером. Стоит отметить, что время, необходимое для выполнения подсчета количества элементов в строке, растет линейно с увеличением
 количества этих элементов (букв). Причиной этому является то, что компьютер
 не может заранее знать, сколько графем-кластеров в коллекции, для этого ему
 необходимо полностью обойти строку с первого до последнего символа.
 Графем-кластеры являются одновременно огромным плюсом стандарта Юникод,
 а также причиной отсутствия в Swift доступа к отдельным символам через целочисленный индекс. Вы не можете просто взять третий или десятый символ, так
 как нет никакой гарантии, что он окажется полноценным графем-кластером, а не
 отдельным символом в его составе. Для доступа к любому элементу коллекции
 типа String необходимо пройти через все предыдущие элементы. Только в этом
 случае можно однозначно получить корректный графем-кластер*/
