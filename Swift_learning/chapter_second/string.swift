//
//  string.swift
//  Swift_learning
//
//  Created by Даниил Асташов on 10.10.2024.
//

import Foundation

/*На концептуальном уровне строка в Swift — это сохраненная в памяти последовательность символов, представленная как коллекция. Да, именно коллекция!
 String соответствует требованиям протокола Collection и является коллекцией,
 подобной массивам, множествам и словарям, но со своими особенностями*/


/*Во-первых, так как String — коллекция, то вам доступно большинство возможностей, характерных для коллекций. К примеру, можно получить количество всех
 элементов с помощью свойства count или for in*/
let str_n = "Hello!"
//str_n.count // 6

/*Каждый элемент строкового значения типа String представляет собой значение
 типа Character, то есть отдельный символ, который может быть представлен с помощью юникод-скаляра (конструкции \u{}, включающей кодовую точку).*/

/*В-третьих, значение типа String — это упорядоченная коллекция. Элементы
 в ней находятся именно в том порядке, какой определил разработчик при инициализации значения.
 На данный момент можно сказать, что строка (значение типа String) — это упорядоченная коллекция, каждый элемент которой представляет собой значение
 типа Character*/

//в swift так не работает
//str[2] // error: 'subscript' is unavailable: cannot subscript String with an Int

//9.2. Графем-кластеры
let char: Character = "\u{E9}"
//char // "é"

let anotherChar: Character = "\u{65}\u{301}"
//anotherChar // "é"

/*И так как тип данных этих параметров — Character, ясно, что в обоих случаях
 для Swift значение состоит из одного символа. Если провести сравнение значений этих переменных, то в результате будет возвращено true, что говорит об их
 идентичности*/
//char == anotherChar // true

/*Дело в том, что в константе anotherChar содержится комбинированный символ, состоящий из двух кодовых точек и, по сути,
 являющийся одним полноценным.
 Существование таких комбинированных символов становится возможным благодаря специальным символам, модифицирующим предыдущий по отношению
 к ним символ (как знак ударения в листинге выше, он изменяет отображение
 латинской буквы e).
 В связи с этим при работе со строковыми значениями не всегда корректным будет
 говорить именно о символах, так как мы видели ранее, что символ по своей сути
 сам может состоять из нескольких символов. В этом случае лучше обратиться
 к понятию графем-кластера.
 Графем-кластер — это совокупность юникод-скаляров (или кодовых точек), при
 визуальном представлении выглядящих как один символ. Графем-кластер может
 состоять из одного или двух юникод-скаляров. Таким образом, в будущем, говоря
 о значении типа Character, мы будем подразумевать не просто отдельный символ,
 а графем-кластер.
 Графем-кластеры могут определять не только буквы алфавита, но и эмодзи. В листинге 9.6 приведен пример комбинирования символов «Thumbs up sign» (кодовая
 точка — 1f44d) и «Emoji Modifier Fitzpatrick Type-4» (кодовая точка — 1f3fd)
 в единый графем-кластер для вывода нового эмодзи (палец вверх со средиземноморским цветом кожи).*/

let thumbsUp = "\u{1f44d}" //
let blackSkin = "\u{1f3fd}" //
let combine = "\u{1f44d}\u{1f3fd}" //

//Вернемся к примеру с символом é. В листинге 9.7 создаются две строки, содержащие данный символ, первая из них содержит непосредственно сам символ é,
//а вторая — комбинацию из латинской e и знака ударения.
//Листинг 9.7
let cafeSimple = "caf\u{E9}" // "café"
let cafeCombine = "cafe\u{301}" // "café"
//cafeSimple.count // 4
//cafeCombine.count // 4

/*Как видно из данного примера, несмотря на то что в переменной cafeCombine
 пять символов, свойство count для обоих вариантов возвращает значение 4. Это
 связано с тем, что для Swift строка — это коллекция символов, каждый из которых
 является графем-кластером. Стоит отметить, что время, необходимое для выполнения подсчета количества элементов в строке, растет линейно с увеличением
 количества этих элементов (букв). Причиной этому является то, что компьютер
 не может заранее знать, сколько графем-кластеров в коллекции, для этого ему
 необходимо полностью обойти строку с первого до последнего символа.
 Графем-кластеры являются одновременно огромным плюсом стандарта Юникод,
 а также причиной отсутствия в Swift доступа к отдельным символам через целочисленный индекс. Вы не можете просто взять третий или десятый символ, так
 как нет никакой гарантии, что он окажется полноценным графем-кластером, а не
 отдельным символом в его составе. Для доступа к любому элементу коллекции
 типа String необходимо пройти через все предыдущие элементы. Только в этом
 случае можно однозначно получить корректный графем-кластер*/


//строковые индексы

let name = "e\u{301}lastic" // "élastic"
let index = name.startIndex
/*Обратите внимание, что первый графем-кластер в константе name состоит из двух
символов. Свойство startIndex возвращает индекс, по которому можно получить
именно графем-кластер, а не первый символ в составе графем-кластера. Теперь
в константе index хранится индекс первой буквы, и его можно использовать точно
так же, как индексы других коллекций (листинг 9.9).*/
//Листинг 9.9
let firstChar = name[index]
//firstChar // "é"
//type(of: firstChar) // Character.Type

//type(of: index) // String.Index.Type

/*Тип строкового индекса — String.Index: это тип данных Index, вложенный в String
 (определенный в данном пространстве имен). С вложенными типами мы встречались ранее во время изучения словарей (Dictionary). Значение типа String.
 Index определяет положение графем-кластера внутри строкового значения, то есть
 содержит ссылки на область памяти, где он начинается и заканчивается. И это,
 конечно же, вовсе не значение типа Int.
 Помимо startIndex, вам доступно свойство endIndex, позволяющее получить
 индекс, который следует за последним символом в строке. Таким образом, он
 указывает не на последний символ, а за него, туда, куда будет добавлен новый
 графем-кластер (то есть добавлена новая буква, если она, конечно, будет добавлена). Если вы попытаетесь использовать значение свойства endIndex напрямую,
 то Swift сообщит о критической ошибке*/

let indexLastChar = name.endIndex
//name[indexLastChar] // Fatal error: String index is out of bounds


/*Метод index(before:) позволяет получить индекс символа, предшествующего
тому, индекс которого передан в качестве аргумента before. Другими словами, передавая в before индекс символа, на выходе вы получите индекс предшествующего
ему символа. Вызывая данный метод, в него можно, к примеру, передать значение
свойства endIndex для получения последнего символа в строке (листинг 9.12).
Листинг 9.12
let lastCharIndex = name.index(before: indexLastChar)
name[lastCharIndex] // "c"
Метод index(after:) позволяет получить индекс последующего символа (листинг 9.13).
Листинг 9.13
let secondCharIndex = name.index(after: name.startIndex)
name[secondCharIndex] // "l"*/

/*
Метод index(_:offsetBy:) позволяет получить требуемый символ с учетом отступа. В качестве значения первого аргумента передается индекс графем-кластера,
от которого будет происходить отсчет, а в качестве значения входного параметра
offsetBy передается целое число, указывающее на отступ вправо (листинг 9.14).
Листинг 9.14
let fourCharIndex = name.index(name.startIndex, offsetBy:3)
name[fourCharIndex] // "s"*/

//количество элементов строки и значение, возвращаемое свойством unicodeScalars, отличаются, так как в составе строки есть
//сложный графем-кластер (состоящий из двух символов).
//name.count // 7
//name.unicodeScalars.count // 8


//подстроки

/*В Swift присутствует тип данных Substring, описывающий подстроку некоторой
 строки. Substring для String — это как ArraySlice для Array. При получении подстроки возвращается значение типа Substring, ссылающееся на ту же область памяти, что и оригинальная строка, а это позволяет экономить ресурсы компьютера.
 Другими словами, основной целью создания типа Substring была оптимизация.
 Значение типа Substring делит одну область памяти с родительской строкой,
 то есть для нее не выделяется дополнительная память*/

let abc = "abcdefghijklmnopqrstuvwxyz"
// индекс первого символа
let firstCharIndex = abc.startIndex
// индекс четвертого символа
let fourthCharIndex = abc.index(firstCharIndex, offsetBy:3)
// получим подстроку
let subAbc = abc[firstCharIndex...fourthCharIndex]
//subAbc // "abcd"
//type(of: subAbc) // Substring.Type


/*Подстроки обладают той же функциональностью, что и строки. Но при необходимости вы всегда можете использовать функцию String(_:) для преобразования
подстроки в строку (листинг 9.17).
Листинг 9.17
type( of: String(subAbc) ) // String.Type
Так же хотелось бы показать пример использования полуоткрытого оператора
диапазона для получения подстроки, состоящей из всех символов, начиная с четвертого и до конца строки. При этом совершенно неважно, какого размера строка,
вы всегда получите все символы до ее конца (листинг 9.18).
Листинг 9.18*/
let subStr = abc[fourthCharIndex...]
//subStr // "defghijklmnopqrstuvwxyz"
